// Copyright The Magewatch Project

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at

//    https://www.apache.org/licenses/LICENSE-2.0

// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";
package api;

option csharp_namespace = "Magewatch.API";

message UserId {
  int32 value = 1;
}

message GameId {
  int32 value = 1;
}

message CreatureId {
  int32 value = 1;
}

message CardId {
  int32 value = 1;
}

enum PlayerName {
  PLAYER_UNSPECIFIED = 0;
  USER = 1;
  ENEMY = 2;
}

enum RankValue {
  RANK_UNSPECIFIED = 0;
  RANK_1 = 2;
  RANK_2 = 3;
  RANK_3 = 4;
  RANK_4 = 5;
  RANK_5 = 6;
}

enum FileValue {
  FILE_UNSPECIFIED = 0;
  FILE_1 = 2;
  FILE_2 = 3;
  FILE_3 = 4;
  FILE_4 = 5;
  FILE_5 = 6;
}

// Requests to start a new game with a new game ID. The client should discard
// all previous state when sending this request.
message StartGameRequest {
}

// Requests to load the current state of a game. The client should discard
// all previous state when sending this request.
message ConnectToGameRequest {
  GameId game_id = 1;
}

// Advance the game to the next phase
message MClickMainButtonRequest {
  GameId game_id = 1;

  PlayerName player = 2;

  uint32 click_event_id = 3;
}

// Play a creature card at a given position
message PlayCreatureCard {
  RankValue rank_position = 1;

  FileValue file_position = 2;
}

// Play an attachment card on a given creature
message PlayAttachmentCard {
  CreatureId creature_id = 1;
}

// Play a card which does not require targeting
message PlayUntargetedCard {
}

// Play a card from the user's hand
message PlayCardRequest {
  GameId game_id = 1;

  PlayerName player = 2;

  CardId card_id = 3;

  oneof play_card {
    PlayCreatureCard play_creature = 4;

    PlayAttachmentCard play_attachment = 5;

    PlayUntargetedCard play_untargeted = 6;
  }
}

message CreaturePositionUpdate {
  CreatureId creature_id = 1;

  RankValue rank_position = 2;

  FileValue file_position = 3;
}

message RepositionCreaturesRequest {
  GameId game_id = 1;

  PlayerName player = 2;

  repeated CreaturePositionUpdate position_updates = 3;
}

// Requests to start a new game with the provided scenario name. The client
// must discard all previous state when sending this request.
message MDebugLoadScenarioRequest {
  string scenario_name = 1;
}

// Specifies specific cards to draw based on their *deck position*
message MDebugDrawCardsRequest {
  repeated uint32 draw_user_cards = 1;
  repeated uint32 draw_enemy_cards = 2;
}

// Run several requests in sequence and return Commands for all of them
message MDebugRunRequestSequenceRequest {
  repeated Request requests = 1;
}

// Data sent to the server whenever the user does something in the game's user
// interface
message Request {
  // Identifies the user making this request
  UserId user_id = 1;

  oneof request {
    StartGameRequest start_game = 2;
    ConnectToGameRequest connect_to_game = 3;
    MClickMainButtonRequest click_main_button = 4;
    PlayCardRequest play_card = 5;
    RepositionCreaturesRequest reposition_creatures = 6;
    MDebugLoadScenarioRequest load_scenario = 8;
    MDebugDrawCardsRequest draw_cards = 9;
    MDebugRunRequestSequenceRequest run_request_sequence = 10;
  }
}

enum InfluenceType {
  INFLUENCE_UNSPECIFIED = 0;
  LIGHT = 1;
  SKY = 2;
  FLAME = 3;
  ICE = 4;
  EARTH = 5;
  SHADOW = 6;
}

message Influence {
  InfluenceType influence_type = 1;

  uint32 value = 2;
}

enum AssetType {
  TYPE_UNSPECIFIED = 0;
  PREFAB = 1;
  SPRITE = 2;
}

message Asset {
  string address = 1;

  AssetType asset_type = 2;
}

// There are two players in a game named "user" and "enemy". The term
// "opponent" can be used to contextually refer to either player
message PlayerData {
  PlayerName player_name = 1;

  uint32 current_life = 2;

  uint32 maximum_life = 3;

  uint32 current_power = 4;

  uint32 maximum_power = 5;

  repeated Influence current_influence = 6;

  repeated Influence maximum_influence = 7;
}

message NoCost {
}

message StandardCost {
  uint32 power_cost = 1;

  repeated Influence influence_cost = 2;
}

message RichText {
  string text = 1;
}

message AttachmentData {
  Asset image = 1;
}

message UntargetedData {
}

message CardData {
  CardId card_id = 1;

  Asset prefab = 2;

  string name = 3;

  oneof cost {
    NoCost no_cost = 4;
    StandardCost standard_cost = 5;
  }

  PlayerName owner = 6;

  // Sprite to display as the card image
  Asset image = 7;

  RichText text = 8;

  // Should this card be shown face-up?
  bool is_revealed = 9;

  // Can the user play this card? i.e. does it have a valid target and can the
  // user pay its costs?
  bool can_be_played = 10;

  oneof card_type {
    CreatureData creature_card = 11;
    AttachmentData attachment_card = 12;
    UntargetedData untargeted_card = 13;
  }
}

message CreatureData {
  CreatureId creature_id = 1;

  Asset prefab = 2;

  PlayerName owner = 3;

  RankValue rank_position = 4;

  FileValue file_position = 5;

  // Can the user change this creature's position?
  bool can_be_repositioned = 6;

  repeated AttachmentData attachments = 7;
}

message DisplayErrorCommand {
  string error = 1;
}

message WaitCommand {
  uint32 wait_time_milliseconds = 1;
}

message MUpdateInterfaceCommand {
  bool main_button_enabled = 1;

  string main_button_text = 2;

  uint32 click_event_id = 13;
}

message UpdatePlayerCommand {
  PlayerData player = 1;
}

message MDrawOrUpdateCardCommand {
  CardData card = 1;
}

message MUpdateCanPlayCardCommand {
  PlayerName player = 1;

  CardId card_id = 2;

  bool can_play = 3;
}

// Reveal an *existing* card and (optionally) animate it to a specific
// rank/file position
message RevealCardCommand {
  CardData card = 1;

  // How long to show the card for before animating it away. 0 should be
  // interpreted as allowing the client to pick its own default.
  uint32 reveal_delay_milliseconds = 2;

  RankValue rank_position = 3;

  FileValue file_position = 4;
}

message CreateOrUpdateCreatureCommand {
  CreatureData creature = 1;
}

message RemoveCreatureCommand {
  CreatureId creature_id = 1;
}

enum MSkillAnimationNumber {
  SKILL_UNSPECIFIED = 0;
  SKILL_1 = 1;
  SKILL_2 = 2;
  SKILL_3 = 3;
  SKILL_4 = 4;
  SKILL_5 = 5;
}

message MSkillAnimation {
  // The animation to perform
  MSkillAnimationNumber skill = 1;

  // How many times this skill is expected to reach its impact frame
  int32 impact_count = 2;
}

// An effect to apply when a skill's impact event fires for the nth time
message MOnImpactNumber {
  // Apply this effect when the skill has reached its impact frame
  // 'on_impact_number' times. A value of 0 should be interpreted the same
  // as 1.
  uint32 impact_number = 1;

  // What to do on impact
  MOnImpact effect = 2;
}

// What to do when a skill or projectile reaches impact
message MOnImpact {
  oneof on_impact {
    // Apply an update
    MCreatureUpdate update = 1;

    // Fire a projectile
    MFireProjectile fire_projectile = 2;
  }
}

message MFireProjectile {
  // Who is firing the projectile?
  CreatureId creature_id = 1;

  // Projectile Prefab to create
  Asset projectile = 2;

  // What to do when the projectile hits
  repeated MOnImpact on_hit = 3;

  oneof target {
    CreatureId target_creature = 4;
  }
}

message MCreatureUpdate {
  CreatureId creature_id = 1;

  // Set this creature's health percentage to a specific value, given as a
  // number between 0 and 1.
  float set_health_percentage = 2;

  // Mark this creature as dead and play its death animation
  bool play_death_animation = 3;

  // Set this creature's mana percentage to a specific value, given as a
  // number between 0 and 1.
  float set_mana_percentage = 4;

  // Play particle effects on this creature
  repeated Asset play_particle_effects = 5;
}

// Updates the state of a creature
message MUpdateCreatureCommand {
  MCreatureUpdate update = 1;
}

// Causes creatures to use skills
message MUseCreatureSkillCommand {
  // Creature to apply these effects to
  CreatureId source_creature = 1;

  // The skill animation to perform
  MSkillAnimation animation = 2;

  // What to do when the skill animation reaches its impact frame
  repeated MOnImpactNumber on_impact = 3;

  // Optionally, a target for this skill. The creature will move into melee
  // range with this target before performing the skill animation.
  CreatureId melee_target = 4;
}

// Requests to destroy a card in a player's hand
message MDestroyCardCommand {
  PlayerName player = 1;

  CardId card_id = 2;

  // If true, it is an error for this card to not exist. Otherwise requests
  // for cards that do not exist are ignored.
  bool must_exist = 3;
}

// Instructs the client to discard all previous state and begin a new game with
// the provided game id.
message MInitiateGameCommand {
  GameId new_game_id = 1;
}

// A single instruction to the client UI to perform some action.
message Command {
  oneof command {
    WaitCommand wait = 1;
    MUpdateInterfaceCommand update_interface = 2;
    MDrawOrUpdateCardCommand draw_or_update_card = 3;
    RevealCardCommand reveal_card = 4;
    UpdatePlayerCommand update_player = 5;
    CreateOrUpdateCreatureCommand create_or_update_creature = 6;
    RemoveCreatureCommand remove_creature = 7;
    MUpdateCreatureCommand update_creature = 10;
    MUseCreatureSkillCommand use_creature_skill = 11;
    DisplayErrorCommand display_error = 12;
    MDestroyCardCommand destroy_card = 13;
    MInitiateGameCommand initiate_game = 14;
    MUpdateCanPlayCardCommand update_can_play_card = 15;
  }
}

// Represents a set of commands which should be executed in parallel,
// operating simultaneously. Position in the command list indicates visually
// which commands happen first
message CommandGroup {
  repeated Command commands = 1;
}

// Represents a sequence of groups of commands which should be executed in
// serial, one after another. Each group is completely executed before the
// next group begins.
 message CommandList {
  repeated CommandGroup command_groups = 1;
}