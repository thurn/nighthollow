// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY MPC(MessagePack-CSharp). DO NOT CHANGE IT.
// </auto-generated>

#pragma warning disable 618
#pragma warning disable 612
#pragma warning disable 414
#pragma warning disable 168

#pragma warning disable SA1200 // Using directives should be placed correctly
#pragma warning disable SA1312 // Variable names should begin with lower-case letter
#pragma warning disable SA1649 // File name should match first type name

namespace MessagePack.Resolvers
{
    using System;

    public class GeneratedResolver : global::MessagePack.IFormatterResolver
    {
        public static readonly global::MessagePack.IFormatterResolver Instance = new GeneratedResolver();

        private GeneratedResolver()
        {
        }

        public global::MessagePack.Formatters.IMessagePackFormatter<T> GetFormatter<T>()
        {
            return FormatterCache<T>.Formatter;
        }

        private static class FormatterCache<T>
        {
            internal static readonly global::MessagePack.Formatters.IMessagePackFormatter<T> Formatter;

            static FormatterCache()
            {
                var f = GeneratedResolverGetFormatterHelper.GetFormatter(typeof(T));
                if (f != null)
                {
                    Formatter = (global::MessagePack.Formatters.IMessagePackFormatter<T>)f;
                }
            }
        }
    }

    internal static class GeneratedResolverGetFormatterHelper
    {
        private static readonly global::System.Collections.Generic.Dictionary<Type, int> lookup;

        static GeneratedResolverGetFormatterHelper()
        {
            lookup = new global::System.Collections.Generic.Dictionary<Type, int>(101)
            {
                { typeof(global::Nighthollow.Data.ImmutableDictionaryValue<global::Nighthollow.Data.DamageType, global::Nighthollow.Stats.IntRangeValue>), 0 },
                { typeof(global::Nighthollow.Data.ImmutableDictionaryValue<global::Nighthollow.Data.DamageType, global::Nighthollow.Stats.PercentageValue>), 1 },
                { typeof(global::Nighthollow.Data.ImmutableDictionaryValue<global::Nighthollow.Data.DamageType, int>), 2 },
                { typeof(global::Nighthollow.Data.ImmutableDictionaryValue<global::Nighthollow.Data.School, int>), 3 },
                { typeof(global::Nighthollow.Data.School?), 4 },
                { typeof(global::Nighthollow.Data.StatTagType?), 5 },
                { typeof(global::Nighthollow.Data.StatType?), 6 },
                { typeof(global::Nighthollow.Delegates.DelegateId?), 7 },
                { typeof(global::Nighthollow.Stats.DurationValue?), 8 },
                { typeof(global::Nighthollow.Stats.ModifierType?), 9 },
                { typeof(global::Nighthollow.Stats.StatId?), 10 },
                { typeof(global::System.Collections.Immutable.ImmutableDictionary<global::Nighthollow.Data.DamageType, global::Nighthollow.Stats.IntRangeValue>), 11 },
                { typeof(global::System.Collections.Immutable.ImmutableDictionary<global::Nighthollow.Data.DamageType, global::Nighthollow.Stats.PercentageValue>), 12 },
                { typeof(global::System.Collections.Immutable.ImmutableDictionary<global::Nighthollow.Data.DamageType, int>), 13 },
                { typeof(global::System.Collections.Immutable.ImmutableDictionary<global::Nighthollow.Data.School, int>), 14 },
                { typeof(global::System.Collections.Immutable.ImmutableDictionary<int, global::Nighthollow.Data.AffixTypeData>), 15 },
                { typeof(global::System.Collections.Immutable.ImmutableDictionary<int, global::Nighthollow.Data.CreatureItemData>), 16 },
                { typeof(global::System.Collections.Immutable.ImmutableDictionary<int, global::Nighthollow.Data.CreatureTypeData>), 17 },
                { typeof(global::System.Collections.Immutable.ImmutableDictionary<int, global::Nighthollow.Data.ModifierData>), 18 },
                { typeof(global::System.Collections.Immutable.ImmutableDictionary<int, global::Nighthollow.Data.SkillTypeData>), 19 },
                { typeof(global::System.Collections.Immutable.ImmutableDictionary<int, global::Nighthollow.Data.StatData>), 20 },
                { typeof(global::System.Collections.Immutable.ImmutableDictionary<int, global::Nighthollow.Data.StaticItemListData>), 21 },
                { typeof(global::System.Collections.Immutable.ImmutableDictionary<int, global::Nighthollow.Data.StatusEffectTypeData>), 22 },
                { typeof(global::System.Collections.Immutable.ImmutableDictionary<int, global::Nighthollow.Data.TableMetadata>), 23 },
                { typeof(global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Data.AffixData>), 24 },
                { typeof(global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Data.CreatureItemData>), 25 },
                { typeof(global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Data.CreatureSkillAnimation>), 26 },
                { typeof(global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Data.ModifierData>), 27 },
                { typeof(global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Data.ResourceItemData>), 28 },
                { typeof(global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Data.SkillItemData>), 29 },
                { typeof(global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Data.StatusEffectItemData>), 30 },
                { typeof(global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Rules.RuleCondition>), 31 },
                { typeof(global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Rules.RuleEffect>), 32 },
                { typeof(global::System.Collections.Immutable.ImmutableList<int>), 33 },
                { typeof(global::Nighthollow.Data.DamageType), 34 },
                { typeof(global::Nighthollow.Data.PlayerName), 35 },
                { typeof(global::Nighthollow.Data.School), 36 },
                { typeof(global::Nighthollow.Data.SkillAnimationNumber), 37 },
                { typeof(global::Nighthollow.Data.SkillAnimationType), 38 },
                { typeof(global::Nighthollow.Data.SkillType), 39 },
                { typeof(global::Nighthollow.Data.StaticItemListData.IdentifierTag), 40 },
                { typeof(global::Nighthollow.Data.StatTagType), 41 },
                { typeof(global::Nighthollow.Data.StatType), 42 },
                { typeof(global::Nighthollow.Delegates.DelegateId), 43 },
                { typeof(global::Nighthollow.Rules.Conditions.IntegerOperator), 44 },
                { typeof(global::Nighthollow.Rules.Effects.CharacterName), 45 },
                { typeof(global::Nighthollow.Rules.Effects.DisplayHelpTextEffect.Direction), 46 },
                { typeof(global::Nighthollow.Rules.Effects.SceneName), 47 },
                { typeof(global::Nighthollow.Rules.EventName), 48 },
                { typeof(global::Nighthollow.Rules.Events.HotkeyPressedEvent.KeyName), 49 },
                { typeof(global::Nighthollow.Rules.RuleCategory), 50 },
                { typeof(global::Nighthollow.Stats.ModifierType), 51 },
                { typeof(global::Nighthollow.Stats.StatId), 52 },
                { typeof(global::Nighthollow.World.Data.HexType), 53 },
                { typeof(global::Nighthollow.World.Data.KingdomName), 54 },
                { typeof(global::Nighthollow.Data.IItemData), 55 },
                { typeof(global::Nighthollow.Data.IValueData), 56 },
                { typeof(global::Nighthollow.Rules.RuleCondition), 57 },
                { typeof(global::Nighthollow.Rules.RuleEffect), 58 },
                { typeof(global::Nighthollow.Components.GameDataHolder), 59 },
                { typeof(global::Nighthollow.Data.AffixData), 60 },
                { typeof(global::Nighthollow.Data.AffixTypeData), 61 },
                { typeof(global::Nighthollow.Data.BattleData), 62 },
                { typeof(global::Nighthollow.Data.BoolValueData), 63 },
                { typeof(global::Nighthollow.Data.CreatureItemData), 64 },
                { typeof(global::Nighthollow.Data.CreatureSkillAnimation), 65 },
                { typeof(global::Nighthollow.Data.CreatureTypeData), 66 },
                { typeof(global::Nighthollow.Data.GlobalData), 67 },
                { typeof(global::Nighthollow.Data.IntValueData), 68 },
                { typeof(global::Nighthollow.Data.ModifierData), 69 },
                { typeof(global::Nighthollow.Data.ResourceItemData), 70 },
                { typeof(global::Nighthollow.Data.SerializationList), 71 },
                { typeof(global::Nighthollow.Data.SkillItemData), 72 },
                { typeof(global::Nighthollow.Data.SkillTypeData), 73 },
                { typeof(global::Nighthollow.Data.StatData), 74 },
                { typeof(global::Nighthollow.Data.StaticItemListData), 75 },
                { typeof(global::Nighthollow.Data.StatusEffectItemData), 76 },
                { typeof(global::Nighthollow.Data.StatusEffectTypeData), 77 },
                { typeof(global::Nighthollow.Data.TableMetadata), 78 },
                { typeof(global::Nighthollow.Data.UserData), 79 },
                { typeof(global::Nighthollow.Editing.Scenarios.ScenarioData), 80 },
                { typeof(global::Nighthollow.Rules.Conditions.HotkeyEqualsCondition), 81 },
                { typeof(global::Nighthollow.Rules.Conditions.UserDeckSizeCondition), 82 },
                { typeof(global::Nighthollow.Rules.Effects.CenterCameraOnHexEffect), 83 },
                { typeof(global::Nighthollow.Rules.Effects.CharacterDialogueEffect), 84 },
                { typeof(global::Nighthollow.Rules.Effects.ClearScenariosEffect), 85 },
                { typeof(global::Nighthollow.Rules.Effects.DisplayHelpTextEffect), 86 },
                { typeof(global::Nighthollow.Rules.Effects.EnableAllRulesEffect), 87 },
                { typeof(global::Nighthollow.Rules.Effects.InitializeWorldMapEffect), 88 },
                { typeof(global::Nighthollow.Rules.Effects.LoadSceneEffect), 89 },
                { typeof(global::Nighthollow.Rules.Effects.PlaceCreaturesFromListEffect), 90 },
                { typeof(global::Nighthollow.Rules.Effects.PreventDefaultEffect), 91 },
                { typeof(global::Nighthollow.Rules.Effects.ResetToNewGameStateEffect), 92 },
                { typeof(global::Nighthollow.Rules.Rule), 93 },
                { typeof(global::Nighthollow.Stats.DurationValue), 94 },
                { typeof(global::Nighthollow.Stats.IntRangeValue), 95 },
                { typeof(global::Nighthollow.Stats.PercentageValue), 96 },
                { typeof(global::Nighthollow.World.Data.ColorData), 97 },
                { typeof(global::Nighthollow.World.Data.HexData), 98 },
                { typeof(global::Nighthollow.World.Data.HexPosition), 99 },
                { typeof(global::Nighthollow.World.Data.KingdomData), 100 },
            };
        }

        internal static object GetFormatter(Type t)
        {
            int key;
            if (!lookup.TryGetValue(t, out key))
            {
                return null;
            }

            switch (key)
            {
                case 0: return new MessagePack.Formatters.Nighthollow.Data.ImmutableDictionaryValueFormatter<global::Nighthollow.Data.DamageType, global::Nighthollow.Stats.IntRangeValue>();
                case 1: return new MessagePack.Formatters.Nighthollow.Data.ImmutableDictionaryValueFormatter<global::Nighthollow.Data.DamageType, global::Nighthollow.Stats.PercentageValue>();
                case 2: return new MessagePack.Formatters.Nighthollow.Data.ImmutableDictionaryValueFormatter<global::Nighthollow.Data.DamageType, int>();
                case 3: return new MessagePack.Formatters.Nighthollow.Data.ImmutableDictionaryValueFormatter<global::Nighthollow.Data.School, int>();
                case 4: return new global::MessagePack.Formatters.NullableFormatter<global::Nighthollow.Data.School>();
                case 5: return new global::MessagePack.Formatters.NullableFormatter<global::Nighthollow.Data.StatTagType>();
                case 6: return new global::MessagePack.Formatters.NullableFormatter<global::Nighthollow.Data.StatType>();
                case 7: return new global::MessagePack.Formatters.NullableFormatter<global::Nighthollow.Delegates.DelegateId>();
                case 8: return new global::MessagePack.Formatters.NullableFormatter<global::Nighthollow.Stats.DurationValue>();
                case 9: return new global::MessagePack.Formatters.NullableFormatter<global::Nighthollow.Stats.ModifierType>();
                case 10: return new global::MessagePack.Formatters.NullableFormatter<global::Nighthollow.Stats.StatId>();
                case 11: return new global::MessagePack.ImmutableCollection.ImmutableDictionaryFormatter<global::Nighthollow.Data.DamageType, global::Nighthollow.Stats.IntRangeValue>();
                case 12: return new global::MessagePack.ImmutableCollection.ImmutableDictionaryFormatter<global::Nighthollow.Data.DamageType, global::Nighthollow.Stats.PercentageValue>();
                case 13: return new global::MessagePack.ImmutableCollection.ImmutableDictionaryFormatter<global::Nighthollow.Data.DamageType, int>();
                case 14: return new global::MessagePack.ImmutableCollection.ImmutableDictionaryFormatter<global::Nighthollow.Data.School, int>();
                case 15: return new global::MessagePack.ImmutableCollection.ImmutableDictionaryFormatter<int, global::Nighthollow.Data.AffixTypeData>();
                case 16: return new global::MessagePack.ImmutableCollection.ImmutableDictionaryFormatter<int, global::Nighthollow.Data.CreatureItemData>();
                case 17: return new global::MessagePack.ImmutableCollection.ImmutableDictionaryFormatter<int, global::Nighthollow.Data.CreatureTypeData>();
                case 18: return new global::MessagePack.ImmutableCollection.ImmutableDictionaryFormatter<int, global::Nighthollow.Data.ModifierData>();
                case 19: return new global::MessagePack.ImmutableCollection.ImmutableDictionaryFormatter<int, global::Nighthollow.Data.SkillTypeData>();
                case 20: return new global::MessagePack.ImmutableCollection.ImmutableDictionaryFormatter<int, global::Nighthollow.Data.StatData>();
                case 21: return new global::MessagePack.ImmutableCollection.ImmutableDictionaryFormatter<int, global::Nighthollow.Data.StaticItemListData>();
                case 22: return new global::MessagePack.ImmutableCollection.ImmutableDictionaryFormatter<int, global::Nighthollow.Data.StatusEffectTypeData>();
                case 23: return new global::MessagePack.ImmutableCollection.ImmutableDictionaryFormatter<int, global::Nighthollow.Data.TableMetadata>();
                case 24: return new global::MessagePack.ImmutableCollection.ImmutableListFormatter<global::Nighthollow.Data.AffixData>();
                case 25: return new global::MessagePack.ImmutableCollection.ImmutableListFormatter<global::Nighthollow.Data.CreatureItemData>();
                case 26: return new global::MessagePack.ImmutableCollection.ImmutableListFormatter<global::Nighthollow.Data.CreatureSkillAnimation>();
                case 27: return new global::MessagePack.ImmutableCollection.ImmutableListFormatter<global::Nighthollow.Data.ModifierData>();
                case 28: return new global::MessagePack.ImmutableCollection.ImmutableListFormatter<global::Nighthollow.Data.ResourceItemData>();
                case 29: return new global::MessagePack.ImmutableCollection.ImmutableListFormatter<global::Nighthollow.Data.SkillItemData>();
                case 30: return new global::MessagePack.ImmutableCollection.ImmutableListFormatter<global::Nighthollow.Data.StatusEffectItemData>();
                case 31: return new global::MessagePack.ImmutableCollection.ImmutableListFormatter<global::Nighthollow.Rules.RuleCondition>();
                case 32: return new global::MessagePack.ImmutableCollection.ImmutableListFormatter<global::Nighthollow.Rules.RuleEffect>();
                case 33: return new global::MessagePack.ImmutableCollection.ImmutableListFormatter<int>();
                case 34: return new MessagePack.Formatters.Nighthollow.Data.DamageTypeFormatter();
                case 35: return new MessagePack.Formatters.Nighthollow.Data.PlayerNameFormatter();
                case 36: return new MessagePack.Formatters.Nighthollow.Data.SchoolFormatter();
                case 37: return new MessagePack.Formatters.Nighthollow.Data.SkillAnimationNumberFormatter();
                case 38: return new MessagePack.Formatters.Nighthollow.Data.SkillAnimationTypeFormatter();
                case 39: return new MessagePack.Formatters.Nighthollow.Data.SkillTypeFormatter();
                case 40: return new MessagePack.Formatters.Nighthollow.Data.StaticItemListData_IdentifierTagFormatter();
                case 41: return new MessagePack.Formatters.Nighthollow.Data.StatTagTypeFormatter();
                case 42: return new MessagePack.Formatters.Nighthollow.Data.StatTypeFormatter();
                case 43: return new MessagePack.Formatters.Nighthollow.Delegates.DelegateIdFormatter();
                case 44: return new MessagePack.Formatters.Nighthollow.Rules.Conditions.IntegerOperatorFormatter();
                case 45: return new MessagePack.Formatters.Nighthollow.Rules.Effects.CharacterNameFormatter();
                case 46: return new MessagePack.Formatters.Nighthollow.Rules.Effects.DisplayHelpTextEffect_DirectionFormatter();
                case 47: return new MessagePack.Formatters.Nighthollow.Rules.Effects.SceneNameFormatter();
                case 48: return new MessagePack.Formatters.Nighthollow.Rules.EventNameFormatter();
                case 49: return new MessagePack.Formatters.Nighthollow.Rules.Events.HotkeyPressedEvent_KeyNameFormatter();
                case 50: return new MessagePack.Formatters.Nighthollow.Rules.RuleCategoryFormatter();
                case 51: return new MessagePack.Formatters.Nighthollow.Stats.ModifierTypeFormatter();
                case 52: return new MessagePack.Formatters.Nighthollow.Stats.StatIdFormatter();
                case 53: return new MessagePack.Formatters.Nighthollow.World.Data.HexTypeFormatter();
                case 54: return new MessagePack.Formatters.Nighthollow.World.Data.KingdomNameFormatter();
                case 55: return new MessagePack.Formatters.Nighthollow.Data.IItemDataFormatter();
                case 56: return new MessagePack.Formatters.Nighthollow.Data.IValueDataFormatter();
                case 57: return new MessagePack.Formatters.Nighthollow.Rules.RuleConditionFormatter();
                case 58: return new MessagePack.Formatters.Nighthollow.Rules.RuleEffectFormatter();
                case 59: return new MessagePack.Formatters.Nighthollow.Components.GameDataHolderFormatter();
                case 60: return new MessagePack.Formatters.Nighthollow.Data.AffixDataFormatter();
                case 61: return new MessagePack.Formatters.Nighthollow.Data.AffixTypeDataFormatter();
                case 62: return new MessagePack.Formatters.Nighthollow.Data.BattleDataFormatter();
                case 63: return new MessagePack.Formatters.Nighthollow.Data.BoolValueDataFormatter();
                case 64: return new MessagePack.Formatters.Nighthollow.Data.CreatureItemDataFormatter();
                case 65: return new MessagePack.Formatters.Nighthollow.Data.CreatureSkillAnimationFormatter();
                case 66: return new MessagePack.Formatters.Nighthollow.Data.CreatureTypeDataFormatter();
                case 67: return new MessagePack.Formatters.Nighthollow.Data.GlobalDataFormatter();
                case 68: return new MessagePack.Formatters.Nighthollow.Data.IntValueDataFormatter();
                case 69: return new MessagePack.Formatters.Nighthollow.Data.ModifierDataFormatter();
                case 70: return new MessagePack.Formatters.Nighthollow.Data.ResourceItemDataFormatter();
                case 71: return new MessagePack.Formatters.Nighthollow.Data.SerializationListFormatter();
                case 72: return new MessagePack.Formatters.Nighthollow.Data.SkillItemDataFormatter();
                case 73: return new MessagePack.Formatters.Nighthollow.Data.SkillTypeDataFormatter();
                case 74: return new MessagePack.Formatters.Nighthollow.Data.StatDataFormatter();
                case 75: return new MessagePack.Formatters.Nighthollow.Data.StaticItemListDataFormatter();
                case 76: return new MessagePack.Formatters.Nighthollow.Data.StatusEffectItemDataFormatter();
                case 77: return new MessagePack.Formatters.Nighthollow.Data.StatusEffectTypeDataFormatter();
                case 78: return new MessagePack.Formatters.Nighthollow.Data.TableMetadataFormatter();
                case 79: return new MessagePack.Formatters.Nighthollow.Data.UserDataFormatter();
                case 80: return new MessagePack.Formatters.Nighthollow.Editing.Scenarios.ScenarioDataFormatter();
                case 81: return new MessagePack.Formatters.Nighthollow.Rules.Conditions.HotkeyEqualsConditionFormatter();
                case 82: return new MessagePack.Formatters.Nighthollow.Rules.Conditions.UserDeckSizeConditionFormatter();
                case 83: return new MessagePack.Formatters.Nighthollow.Rules.Effects.CenterCameraOnHexEffectFormatter();
                case 84: return new MessagePack.Formatters.Nighthollow.Rules.Effects.CharacterDialogueEffectFormatter();
                case 85: return new MessagePack.Formatters.Nighthollow.Rules.Effects.ClearScenariosEffectFormatter();
                case 86: return new MessagePack.Formatters.Nighthollow.Rules.Effects.DisplayHelpTextEffectFormatter();
                case 87: return new MessagePack.Formatters.Nighthollow.Rules.Effects.EnableAllRulesEffectFormatter();
                case 88: return new MessagePack.Formatters.Nighthollow.Rules.Effects.InitializeWorldMapEffectFormatter();
                case 89: return new MessagePack.Formatters.Nighthollow.Rules.Effects.LoadSceneEffectFormatter();
                case 90: return new MessagePack.Formatters.Nighthollow.Rules.Effects.PlaceCreaturesFromListEffectFormatter();
                case 91: return new MessagePack.Formatters.Nighthollow.Rules.Effects.PreventDefaultEffectFormatter();
                case 92: return new MessagePack.Formatters.Nighthollow.Rules.Effects.ResetToNewGameStateEffectFormatter();
                case 93: return new MessagePack.Formatters.Nighthollow.Rules.RuleFormatter();
                case 94: return new MessagePack.Formatters.Nighthollow.Stats.DurationValueFormatter();
                case 95: return new MessagePack.Formatters.Nighthollow.Stats.IntRangeValueFormatter();
                case 96: return new MessagePack.Formatters.Nighthollow.Stats.PercentageValueFormatter();
                case 97: return new MessagePack.Formatters.Nighthollow.World.Data.ColorDataFormatter();
                case 98: return new MessagePack.Formatters.Nighthollow.World.Data.HexDataFormatter();
                case 99: return new MessagePack.Formatters.Nighthollow.World.Data.HexPositionFormatter();
                case 100: return new MessagePack.Formatters.Nighthollow.World.Data.KingdomDataFormatter();
                default: return null;
            }
        }
    }
}

#pragma warning restore 168
#pragma warning restore 414
#pragma warning restore 618
#pragma warning restore 612

#pragma warning restore SA1312 // Variable names should begin with lower-case letter
#pragma warning restore SA1200 // Using directives should be placed correctly
#pragma warning restore SA1649 // File name should match first type name


// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY MPC(MessagePack-CSharp). DO NOT CHANGE IT.
// </auto-generated>

#pragma warning disable 618
#pragma warning disable 612
#pragma warning disable 414
#pragma warning disable 168

#pragma warning disable SA1200 // Using directives should be placed correctly
#pragma warning disable SA1403 // File may only contain a single namespace
#pragma warning disable SA1649 // File name should match first type name

namespace MessagePack.Formatters.Nighthollow.Data
{
    using System;
    using System.Buffers;
    using MessagePack;

    public sealed class DamageTypeFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Nighthollow.Data.DamageType>
    {
        public void Serialize(ref MessagePackWriter writer, global::Nighthollow.Data.DamageType value, global::MessagePack.MessagePackSerializerOptions options)
        {
            writer.Write((Int32)value);
        }

        public global::Nighthollow.Data.DamageType Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            return (global::Nighthollow.Data.DamageType)reader.ReadInt32();
        }
    }

    public sealed class PlayerNameFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Nighthollow.Data.PlayerName>
    {
        public void Serialize(ref MessagePackWriter writer, global::Nighthollow.Data.PlayerName value, global::MessagePack.MessagePackSerializerOptions options)
        {
            writer.Write((Int32)value);
        }

        public global::Nighthollow.Data.PlayerName Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            return (global::Nighthollow.Data.PlayerName)reader.ReadInt32();
        }
    }

    public sealed class SchoolFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Nighthollow.Data.School>
    {
        public void Serialize(ref MessagePackWriter writer, global::Nighthollow.Data.School value, global::MessagePack.MessagePackSerializerOptions options)
        {
            writer.Write((Int32)value);
        }

        public global::Nighthollow.Data.School Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            return (global::Nighthollow.Data.School)reader.ReadInt32();
        }
    }

    public sealed class SkillAnimationNumberFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Nighthollow.Data.SkillAnimationNumber>
    {
        public void Serialize(ref MessagePackWriter writer, global::Nighthollow.Data.SkillAnimationNumber value, global::MessagePack.MessagePackSerializerOptions options)
        {
            writer.Write((Int32)value);
        }

        public global::Nighthollow.Data.SkillAnimationNumber Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            return (global::Nighthollow.Data.SkillAnimationNumber)reader.ReadInt32();
        }
    }

    public sealed class SkillAnimationTypeFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Nighthollow.Data.SkillAnimationType>
    {
        public void Serialize(ref MessagePackWriter writer, global::Nighthollow.Data.SkillAnimationType value, global::MessagePack.MessagePackSerializerOptions options)
        {
            writer.Write((Int32)value);
        }

        public global::Nighthollow.Data.SkillAnimationType Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            return (global::Nighthollow.Data.SkillAnimationType)reader.ReadInt32();
        }
    }

    public sealed class SkillTypeFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Nighthollow.Data.SkillType>
    {
        public void Serialize(ref MessagePackWriter writer, global::Nighthollow.Data.SkillType value, global::MessagePack.MessagePackSerializerOptions options)
        {
            writer.Write((Int32)value);
        }

        public global::Nighthollow.Data.SkillType Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            return (global::Nighthollow.Data.SkillType)reader.ReadInt32();
        }
    }

    public sealed class StaticItemListData_IdentifierTagFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Nighthollow.Data.StaticItemListData.IdentifierTag>
    {
        public void Serialize(ref MessagePackWriter writer, global::Nighthollow.Data.StaticItemListData.IdentifierTag value, global::MessagePack.MessagePackSerializerOptions options)
        {
            writer.Write((Int32)value);
        }

        public global::Nighthollow.Data.StaticItemListData.IdentifierTag Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            return (global::Nighthollow.Data.StaticItemListData.IdentifierTag)reader.ReadInt32();
        }
    }

    public sealed class StatTagTypeFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Nighthollow.Data.StatTagType>
    {
        public void Serialize(ref MessagePackWriter writer, global::Nighthollow.Data.StatTagType value, global::MessagePack.MessagePackSerializerOptions options)
        {
            writer.Write((Int32)value);
        }

        public global::Nighthollow.Data.StatTagType Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            return (global::Nighthollow.Data.StatTagType)reader.ReadInt32();
        }
    }

    public sealed class StatTypeFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Nighthollow.Data.StatType>
    {
        public void Serialize(ref MessagePackWriter writer, global::Nighthollow.Data.StatType value, global::MessagePack.MessagePackSerializerOptions options)
        {
            writer.Write((Int32)value);
        }

        public global::Nighthollow.Data.StatType Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            return (global::Nighthollow.Data.StatType)reader.ReadInt32();
        }
    }
}

#pragma warning restore 168
#pragma warning restore 414
#pragma warning restore 618
#pragma warning restore 612

#pragma warning restore SA1200 // Using directives should be placed correctly
#pragma warning restore SA1403 // File may only contain a single namespace
#pragma warning restore SA1649 // File name should match first type name

// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY MPC(MessagePack-CSharp). DO NOT CHANGE IT.
// </auto-generated>

#pragma warning disable 618
#pragma warning disable 612
#pragma warning disable 414
#pragma warning disable 168

#pragma warning disable SA1200 // Using directives should be placed correctly
#pragma warning disable SA1403 // File may only contain a single namespace
#pragma warning disable SA1649 // File name should match first type name

namespace MessagePack.Formatters.Nighthollow.Delegates
{
    using System;
    using System.Buffers;
    using MessagePack;

    public sealed class DelegateIdFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Nighthollow.Delegates.DelegateId>
    {
        public void Serialize(ref MessagePackWriter writer, global::Nighthollow.Delegates.DelegateId value, global::MessagePack.MessagePackSerializerOptions options)
        {
            writer.Write((Int32)value);
        }

        public global::Nighthollow.Delegates.DelegateId Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            return (global::Nighthollow.Delegates.DelegateId)reader.ReadInt32();
        }
    }
}

#pragma warning restore 168
#pragma warning restore 414
#pragma warning restore 618
#pragma warning restore 612

#pragma warning restore SA1200 // Using directives should be placed correctly
#pragma warning restore SA1403 // File may only contain a single namespace
#pragma warning restore SA1649 // File name should match first type name

// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY MPC(MessagePack-CSharp). DO NOT CHANGE IT.
// </auto-generated>

#pragma warning disable 618
#pragma warning disable 612
#pragma warning disable 414
#pragma warning disable 168

#pragma warning disable SA1200 // Using directives should be placed correctly
#pragma warning disable SA1403 // File may only contain a single namespace
#pragma warning disable SA1649 // File name should match first type name

namespace MessagePack.Formatters.Nighthollow.Rules.Conditions
{
    using System;
    using System.Buffers;
    using MessagePack;

    public sealed class IntegerOperatorFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Nighthollow.Rules.Conditions.IntegerOperator>
    {
        public void Serialize(ref MessagePackWriter writer, global::Nighthollow.Rules.Conditions.IntegerOperator value, global::MessagePack.MessagePackSerializerOptions options)
        {
            writer.Write((Int32)value);
        }

        public global::Nighthollow.Rules.Conditions.IntegerOperator Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            return (global::Nighthollow.Rules.Conditions.IntegerOperator)reader.ReadInt32();
        }
    }
}

#pragma warning restore 168
#pragma warning restore 414
#pragma warning restore 618
#pragma warning restore 612

#pragma warning restore SA1200 // Using directives should be placed correctly
#pragma warning restore SA1403 // File may only contain a single namespace
#pragma warning restore SA1649 // File name should match first type name

// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY MPC(MessagePack-CSharp). DO NOT CHANGE IT.
// </auto-generated>

#pragma warning disable 618
#pragma warning disable 612
#pragma warning disable 414
#pragma warning disable 168

#pragma warning disable SA1200 // Using directives should be placed correctly
#pragma warning disable SA1403 // File may only contain a single namespace
#pragma warning disable SA1649 // File name should match first type name

namespace MessagePack.Formatters.Nighthollow.Rules.Effects
{
    using System;
    using System.Buffers;
    using MessagePack;

    public sealed class CharacterNameFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Nighthollow.Rules.Effects.CharacterName>
    {
        public void Serialize(ref MessagePackWriter writer, global::Nighthollow.Rules.Effects.CharacterName value, global::MessagePack.MessagePackSerializerOptions options)
        {
            writer.Write((Int32)value);
        }

        public global::Nighthollow.Rules.Effects.CharacterName Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            return (global::Nighthollow.Rules.Effects.CharacterName)reader.ReadInt32();
        }
    }

    public sealed class DisplayHelpTextEffect_DirectionFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Nighthollow.Rules.Effects.DisplayHelpTextEffect.Direction>
    {
        public void Serialize(ref MessagePackWriter writer, global::Nighthollow.Rules.Effects.DisplayHelpTextEffect.Direction value, global::MessagePack.MessagePackSerializerOptions options)
        {
            writer.Write((Int32)value);
        }

        public global::Nighthollow.Rules.Effects.DisplayHelpTextEffect.Direction Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            return (global::Nighthollow.Rules.Effects.DisplayHelpTextEffect.Direction)reader.ReadInt32();
        }
    }

    public sealed class SceneNameFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Nighthollow.Rules.Effects.SceneName>
    {
        public void Serialize(ref MessagePackWriter writer, global::Nighthollow.Rules.Effects.SceneName value, global::MessagePack.MessagePackSerializerOptions options)
        {
            writer.Write((Int32)value);
        }

        public global::Nighthollow.Rules.Effects.SceneName Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            return (global::Nighthollow.Rules.Effects.SceneName)reader.ReadInt32();
        }
    }
}

#pragma warning restore 168
#pragma warning restore 414
#pragma warning restore 618
#pragma warning restore 612

#pragma warning restore SA1200 // Using directives should be placed correctly
#pragma warning restore SA1403 // File may only contain a single namespace
#pragma warning restore SA1649 // File name should match first type name

// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY MPC(MessagePack-CSharp). DO NOT CHANGE IT.
// </auto-generated>

#pragma warning disable 618
#pragma warning disable 612
#pragma warning disable 414
#pragma warning disable 168

#pragma warning disable SA1200 // Using directives should be placed correctly
#pragma warning disable SA1403 // File may only contain a single namespace
#pragma warning disable SA1649 // File name should match first type name

namespace MessagePack.Formatters.Nighthollow.Rules
{
    using System;
    using System.Buffers;
    using MessagePack;

    public sealed class EventNameFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Nighthollow.Rules.EventName>
    {
        public void Serialize(ref MessagePackWriter writer, global::Nighthollow.Rules.EventName value, global::MessagePack.MessagePackSerializerOptions options)
        {
            writer.Write((Int32)value);
        }

        public global::Nighthollow.Rules.EventName Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            return (global::Nighthollow.Rules.EventName)reader.ReadInt32();
        }
    }

    public sealed class RuleCategoryFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Nighthollow.Rules.RuleCategory>
    {
        public void Serialize(ref MessagePackWriter writer, global::Nighthollow.Rules.RuleCategory value, global::MessagePack.MessagePackSerializerOptions options)
        {
            writer.Write((Int32)value);
        }

        public global::Nighthollow.Rules.RuleCategory Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            return (global::Nighthollow.Rules.RuleCategory)reader.ReadInt32();
        }
    }
}

#pragma warning restore 168
#pragma warning restore 414
#pragma warning restore 618
#pragma warning restore 612

#pragma warning restore SA1200 // Using directives should be placed correctly
#pragma warning restore SA1403 // File may only contain a single namespace
#pragma warning restore SA1649 // File name should match first type name

// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY MPC(MessagePack-CSharp). DO NOT CHANGE IT.
// </auto-generated>

#pragma warning disable 618
#pragma warning disable 612
#pragma warning disable 414
#pragma warning disable 168

#pragma warning disable SA1200 // Using directives should be placed correctly
#pragma warning disable SA1403 // File may only contain a single namespace
#pragma warning disable SA1649 // File name should match first type name

namespace MessagePack.Formatters.Nighthollow.Rules.Events
{
    using System;
    using System.Buffers;
    using MessagePack;

    public sealed class HotkeyPressedEvent_KeyNameFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Nighthollow.Rules.Events.HotkeyPressedEvent.KeyName>
    {
        public void Serialize(ref MessagePackWriter writer, global::Nighthollow.Rules.Events.HotkeyPressedEvent.KeyName value, global::MessagePack.MessagePackSerializerOptions options)
        {
            writer.Write((Int32)value);
        }

        public global::Nighthollow.Rules.Events.HotkeyPressedEvent.KeyName Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            return (global::Nighthollow.Rules.Events.HotkeyPressedEvent.KeyName)reader.ReadInt32();
        }
    }
}

#pragma warning restore 168
#pragma warning restore 414
#pragma warning restore 618
#pragma warning restore 612

#pragma warning restore SA1200 // Using directives should be placed correctly
#pragma warning restore SA1403 // File may only contain a single namespace
#pragma warning restore SA1649 // File name should match first type name

// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY MPC(MessagePack-CSharp). DO NOT CHANGE IT.
// </auto-generated>

#pragma warning disable 618
#pragma warning disable 612
#pragma warning disable 414
#pragma warning disable 168

#pragma warning disable SA1200 // Using directives should be placed correctly
#pragma warning disable SA1403 // File may only contain a single namespace
#pragma warning disable SA1649 // File name should match first type name

namespace MessagePack.Formatters.Nighthollow.Stats
{
    using System;
    using System.Buffers;
    using MessagePack;

    public sealed class ModifierTypeFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Nighthollow.Stats.ModifierType>
    {
        public void Serialize(ref MessagePackWriter writer, global::Nighthollow.Stats.ModifierType value, global::MessagePack.MessagePackSerializerOptions options)
        {
            writer.Write((Int32)value);
        }

        public global::Nighthollow.Stats.ModifierType Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            return (global::Nighthollow.Stats.ModifierType)reader.ReadInt32();
        }
    }

    public sealed class StatIdFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Nighthollow.Stats.StatId>
    {
        public void Serialize(ref MessagePackWriter writer, global::Nighthollow.Stats.StatId value, global::MessagePack.MessagePackSerializerOptions options)
        {
            writer.Write((Int32)value);
        }

        public global::Nighthollow.Stats.StatId Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            return (global::Nighthollow.Stats.StatId)reader.ReadInt32();
        }
    }
}

#pragma warning restore 168
#pragma warning restore 414
#pragma warning restore 618
#pragma warning restore 612

#pragma warning restore SA1200 // Using directives should be placed correctly
#pragma warning restore SA1403 // File may only contain a single namespace
#pragma warning restore SA1649 // File name should match first type name

// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY MPC(MessagePack-CSharp). DO NOT CHANGE IT.
// </auto-generated>

#pragma warning disable 618
#pragma warning disable 612
#pragma warning disable 414
#pragma warning disable 168

#pragma warning disable SA1200 // Using directives should be placed correctly
#pragma warning disable SA1403 // File may only contain a single namespace
#pragma warning disable SA1649 // File name should match first type name

namespace MessagePack.Formatters.Nighthollow.World.Data
{
    using System;
    using System.Buffers;
    using MessagePack;

    public sealed class HexTypeFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Nighthollow.World.Data.HexType>
    {
        public void Serialize(ref MessagePackWriter writer, global::Nighthollow.World.Data.HexType value, global::MessagePack.MessagePackSerializerOptions options)
        {
            writer.Write((Int32)value);
        }

        public global::Nighthollow.World.Data.HexType Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            return (global::Nighthollow.World.Data.HexType)reader.ReadInt32();
        }
    }

    public sealed class KingdomNameFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Nighthollow.World.Data.KingdomName>
    {
        public void Serialize(ref MessagePackWriter writer, global::Nighthollow.World.Data.KingdomName value, global::MessagePack.MessagePackSerializerOptions options)
        {
            writer.Write((Int32)value);
        }

        public global::Nighthollow.World.Data.KingdomName Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            return (global::Nighthollow.World.Data.KingdomName)reader.ReadInt32();
        }
    }
}

#pragma warning restore 168
#pragma warning restore 414
#pragma warning restore 618
#pragma warning restore 612

#pragma warning restore SA1200 // Using directives should be placed correctly
#pragma warning restore SA1403 // File may only contain a single namespace
#pragma warning restore SA1649 // File name should match first type name


// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY MPC(MessagePack-CSharp). DO NOT CHANGE IT.
// </auto-generated>

#pragma warning disable 618
#pragma warning disable 612
#pragma warning disable 414
#pragma warning disable 168

#pragma warning disable SA1200 // Using directives should be placed correctly
#pragma warning disable SA1403 // File may only contain a single namespace
#pragma warning disable SA1649 // File name should match first type name

namespace MessagePack.Formatters.Nighthollow.Data
{
    using System;
    using System.Buffers;
    using System.Collections.Generic;
    using MessagePack;

    public sealed class IItemDataFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Nighthollow.Data.IItemData>
    {
        private readonly Dictionary<RuntimeTypeHandle, KeyValuePair<int, int>> typeToKeyAndJumpMap;
        private readonly Dictionary<int, int> keyToJumpMap;

        public IItemDataFormatter()
        {
            this.typeToKeyAndJumpMap = new Dictionary<RuntimeTypeHandle, KeyValuePair<int, int>>(2, global::MessagePack.Internal.RuntimeTypeHandleEqualityComparer.Default)
            {
                { typeof(global::Nighthollow.Data.CreatureItemData).TypeHandle, new KeyValuePair<int, int>(0, 0) },
                { typeof(global::Nighthollow.Data.ResourceItemData).TypeHandle, new KeyValuePair<int, int>(1, 1) },
            };
            this.keyToJumpMap = new Dictionary<int, int>(2)
            {
                { 0, 0 },
                { 1, 1 },
            };
        }

        public void Serialize(ref MessagePackWriter writer, global::Nighthollow.Data.IItemData value, global::MessagePack.MessagePackSerializerOptions options)
        {
            KeyValuePair<int, int> keyValuePair;
            if (value != null && this.typeToKeyAndJumpMap.TryGetValue(value.GetType().TypeHandle, out keyValuePair))
            {
                writer.WriteArrayHeader(2);
                writer.WriteInt32(keyValuePair.Key);
                switch (keyValuePair.Value)
                {
                    case 0:
                        options.Resolver.GetFormatterWithVerify<global::Nighthollow.Data.CreatureItemData>().Serialize(ref writer, (global::Nighthollow.Data.CreatureItemData)value, options);
                        break;
                    case 1:
                        options.Resolver.GetFormatterWithVerify<global::Nighthollow.Data.ResourceItemData>().Serialize(ref writer, (global::Nighthollow.Data.ResourceItemData)value, options);
                        break;
                    default:
                        break;
                }

                return;
            }

            writer.WriteNil();
        }

        public global::Nighthollow.Data.IItemData Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            if (reader.ReadArrayHeader() != 2)
            {
                throw new InvalidOperationException("Invalid Union data was detected. Type:global::Nighthollow.Data.IItemData");
            }

            options.Security.DepthStep(ref reader);
            var key = reader.ReadInt32();

            if (!this.keyToJumpMap.TryGetValue(key, out key))
            {
                key = -1;
            }

            global::Nighthollow.Data.IItemData result = null;
            switch (key)
            {
                case 0:
                    result = (global::Nighthollow.Data.IItemData)options.Resolver.GetFormatterWithVerify<global::Nighthollow.Data.CreatureItemData>().Deserialize(ref reader, options);
                    break;
                case 1:
                    result = (global::Nighthollow.Data.IItemData)options.Resolver.GetFormatterWithVerify<global::Nighthollow.Data.ResourceItemData>().Deserialize(ref reader, options);
                    break;
                default:
                    reader.Skip();
                    break;
            }

            reader.Depth--;
            return result;
        }
    }

    public sealed class IValueDataFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Nighthollow.Data.IValueData>
    {
        private readonly Dictionary<RuntimeTypeHandle, KeyValuePair<int, int>> typeToKeyAndJumpMap;
        private readonly Dictionary<int, int> keyToJumpMap;

        public IValueDataFormatter()
        {
            this.typeToKeyAndJumpMap = new Dictionary<RuntimeTypeHandle, KeyValuePair<int, int>>(9, global::MessagePack.Internal.RuntimeTypeHandleEqualityComparer.Default)
            {
                { typeof(global::Nighthollow.Data.IntValueData).TypeHandle, new KeyValuePair<int, int>(0, 0) },
                { typeof(global::Nighthollow.Stats.DurationValue).TypeHandle, new KeyValuePair<int, int>(1, 1) },
                { typeof(global::Nighthollow.Stats.PercentageValue).TypeHandle, new KeyValuePair<int, int>(2, 2) },
                { typeof(global::Nighthollow.Stats.IntRangeValue).TypeHandle, new KeyValuePair<int, int>(3, 3) },
                { typeof(global::Nighthollow.Data.BoolValueData).TypeHandle, new KeyValuePair<int, int>(4, 4) },
                { typeof(global::Nighthollow.Data.ImmutableDictionaryValue<global::Nighthollow.Data.DamageType, int>).TypeHandle, new KeyValuePair<int, int>(5, 5) },
                { typeof(global::Nighthollow.Data.ImmutableDictionaryValue<global::Nighthollow.Data.DamageType, global::Nighthollow.Stats.PercentageValue>).TypeHandle, new KeyValuePair<int, int>(6, 6) },
                { typeof(global::Nighthollow.Data.ImmutableDictionaryValue<global::Nighthollow.Data.DamageType, global::Nighthollow.Stats.IntRangeValue>).TypeHandle, new KeyValuePair<int, int>(7, 7) },
                { typeof(global::Nighthollow.Data.ImmutableDictionaryValue<global::Nighthollow.Data.School, int>).TypeHandle, new KeyValuePair<int, int>(8, 8) },
            };
            this.keyToJumpMap = new Dictionary<int, int>(9)
            {
                { 0, 0 },
                { 1, 1 },
                { 2, 2 },
                { 3, 3 },
                { 4, 4 },
                { 5, 5 },
                { 6, 6 },
                { 7, 7 },
                { 8, 8 },
            };
        }

        public void Serialize(ref MessagePackWriter writer, global::Nighthollow.Data.IValueData value, global::MessagePack.MessagePackSerializerOptions options)
        {
            KeyValuePair<int, int> keyValuePair;
            if (value != null && this.typeToKeyAndJumpMap.TryGetValue(value.GetType().TypeHandle, out keyValuePair))
            {
                writer.WriteArrayHeader(2);
                writer.WriteInt32(keyValuePair.Key);
                switch (keyValuePair.Value)
                {
                    case 0:
                        options.Resolver.GetFormatterWithVerify<global::Nighthollow.Data.IntValueData>().Serialize(ref writer, (global::Nighthollow.Data.IntValueData)value, options);
                        break;
                    case 1:
                        options.Resolver.GetFormatterWithVerify<global::Nighthollow.Stats.DurationValue>().Serialize(ref writer, (global::Nighthollow.Stats.DurationValue)value, options);
                        break;
                    case 2:
                        options.Resolver.GetFormatterWithVerify<global::Nighthollow.Stats.PercentageValue>().Serialize(ref writer, (global::Nighthollow.Stats.PercentageValue)value, options);
                        break;
                    case 3:
                        options.Resolver.GetFormatterWithVerify<global::Nighthollow.Stats.IntRangeValue>().Serialize(ref writer, (global::Nighthollow.Stats.IntRangeValue)value, options);
                        break;
                    case 4:
                        options.Resolver.GetFormatterWithVerify<global::Nighthollow.Data.BoolValueData>().Serialize(ref writer, (global::Nighthollow.Data.BoolValueData)value, options);
                        break;
                    case 5:
                        options.Resolver.GetFormatterWithVerify<global::Nighthollow.Data.ImmutableDictionaryValue<global::Nighthollow.Data.DamageType, int>>().Serialize(ref writer, (global::Nighthollow.Data.ImmutableDictionaryValue<global::Nighthollow.Data.DamageType, int>)value, options);
                        break;
                    case 6:
                        options.Resolver.GetFormatterWithVerify<global::Nighthollow.Data.ImmutableDictionaryValue<global::Nighthollow.Data.DamageType, global::Nighthollow.Stats.PercentageValue>>().Serialize(ref writer, (global::Nighthollow.Data.ImmutableDictionaryValue<global::Nighthollow.Data.DamageType, global::Nighthollow.Stats.PercentageValue>)value, options);
                        break;
                    case 7:
                        options.Resolver.GetFormatterWithVerify<global::Nighthollow.Data.ImmutableDictionaryValue<global::Nighthollow.Data.DamageType, global::Nighthollow.Stats.IntRangeValue>>().Serialize(ref writer, (global::Nighthollow.Data.ImmutableDictionaryValue<global::Nighthollow.Data.DamageType, global::Nighthollow.Stats.IntRangeValue>)value, options);
                        break;
                    case 8:
                        options.Resolver.GetFormatterWithVerify<global::Nighthollow.Data.ImmutableDictionaryValue<global::Nighthollow.Data.School, int>>().Serialize(ref writer, (global::Nighthollow.Data.ImmutableDictionaryValue<global::Nighthollow.Data.School, int>)value, options);
                        break;
                    default:
                        break;
                }

                return;
            }

            writer.WriteNil();
        }

        public global::Nighthollow.Data.IValueData Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            if (reader.ReadArrayHeader() != 2)
            {
                throw new InvalidOperationException("Invalid Union data was detected. Type:global::Nighthollow.Data.IValueData");
            }

            options.Security.DepthStep(ref reader);
            var key = reader.ReadInt32();

            if (!this.keyToJumpMap.TryGetValue(key, out key))
            {
                key = -1;
            }

            global::Nighthollow.Data.IValueData result = null;
            switch (key)
            {
                case 0:
                    result = (global::Nighthollow.Data.IValueData)options.Resolver.GetFormatterWithVerify<global::Nighthollow.Data.IntValueData>().Deserialize(ref reader, options);
                    break;
                case 1:
                    result = (global::Nighthollow.Data.IValueData)options.Resolver.GetFormatterWithVerify<global::Nighthollow.Stats.DurationValue>().Deserialize(ref reader, options);
                    break;
                case 2:
                    result = (global::Nighthollow.Data.IValueData)options.Resolver.GetFormatterWithVerify<global::Nighthollow.Stats.PercentageValue>().Deserialize(ref reader, options);
                    break;
                case 3:
                    result = (global::Nighthollow.Data.IValueData)options.Resolver.GetFormatterWithVerify<global::Nighthollow.Stats.IntRangeValue>().Deserialize(ref reader, options);
                    break;
                case 4:
                    result = (global::Nighthollow.Data.IValueData)options.Resolver.GetFormatterWithVerify<global::Nighthollow.Data.BoolValueData>().Deserialize(ref reader, options);
                    break;
                case 5:
                    result = (global::Nighthollow.Data.IValueData)options.Resolver.GetFormatterWithVerify<global::Nighthollow.Data.ImmutableDictionaryValue<global::Nighthollow.Data.DamageType, int>>().Deserialize(ref reader, options);
                    break;
                case 6:
                    result = (global::Nighthollow.Data.IValueData)options.Resolver.GetFormatterWithVerify<global::Nighthollow.Data.ImmutableDictionaryValue<global::Nighthollow.Data.DamageType, global::Nighthollow.Stats.PercentageValue>>().Deserialize(ref reader, options);
                    break;
                case 7:
                    result = (global::Nighthollow.Data.IValueData)options.Resolver.GetFormatterWithVerify<global::Nighthollow.Data.ImmutableDictionaryValue<global::Nighthollow.Data.DamageType, global::Nighthollow.Stats.IntRangeValue>>().Deserialize(ref reader, options);
                    break;
                case 8:
                    result = (global::Nighthollow.Data.IValueData)options.Resolver.GetFormatterWithVerify<global::Nighthollow.Data.ImmutableDictionaryValue<global::Nighthollow.Data.School, int>>().Deserialize(ref reader, options);
                    break;
                default:
                    reader.Skip();
                    break;
            }

            reader.Depth--;
            return result;
        }
    }


}

#pragma warning restore 168
#pragma warning restore 414
#pragma warning restore 618
#pragma warning restore 612

#pragma warning restore SA1200 // Using directives should be placed correctly
#pragma warning restore SA1403 // File may only contain a single namespace
#pragma warning restore SA1649 // File name should match first type name

// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY MPC(MessagePack-CSharp). DO NOT CHANGE IT.
// </auto-generated>

#pragma warning disable 618
#pragma warning disable 612
#pragma warning disable 414
#pragma warning disable 168

#pragma warning disable SA1200 // Using directives should be placed correctly
#pragma warning disable SA1403 // File may only contain a single namespace
#pragma warning disable SA1649 // File name should match first type name

namespace MessagePack.Formatters.Nighthollow.Rules
{
    using System;
    using System.Buffers;
    using System.Collections.Generic;
    using MessagePack;

    public sealed class RuleConditionFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Nighthollow.Rules.RuleCondition>
    {
        private readonly Dictionary<RuntimeTypeHandle, KeyValuePair<int, int>> typeToKeyAndJumpMap;
        private readonly Dictionary<int, int> keyToJumpMap;

        public RuleConditionFormatter()
        {
            this.typeToKeyAndJumpMap = new Dictionary<RuntimeTypeHandle, KeyValuePair<int, int>>(2, global::MessagePack.Internal.RuntimeTypeHandleEqualityComparer.Default)
            {
                { typeof(global::Nighthollow.Rules.Conditions.UserDeckSizeCondition).TypeHandle, new KeyValuePair<int, int>(0, 0) },
                { typeof(global::Nighthollow.Rules.Conditions.HotkeyEqualsCondition).TypeHandle, new KeyValuePair<int, int>(1, 1) },
            };
            this.keyToJumpMap = new Dictionary<int, int>(2)
            {
                { 0, 0 },
                { 1, 1 },
            };
        }

        public void Serialize(ref MessagePackWriter writer, global::Nighthollow.Rules.RuleCondition value, global::MessagePack.MessagePackSerializerOptions options)
        {
            KeyValuePair<int, int> keyValuePair;
            if (value != null && this.typeToKeyAndJumpMap.TryGetValue(value.GetType().TypeHandle, out keyValuePair))
            {
                writer.WriteArrayHeader(2);
                writer.WriteInt32(keyValuePair.Key);
                switch (keyValuePair.Value)
                {
                    case 0:
                        options.Resolver.GetFormatterWithVerify<global::Nighthollow.Rules.Conditions.UserDeckSizeCondition>().Serialize(ref writer, (global::Nighthollow.Rules.Conditions.UserDeckSizeCondition)value, options);
                        break;
                    case 1:
                        options.Resolver.GetFormatterWithVerify<global::Nighthollow.Rules.Conditions.HotkeyEqualsCondition>().Serialize(ref writer, (global::Nighthollow.Rules.Conditions.HotkeyEqualsCondition)value, options);
                        break;
                    default:
                        break;
                }

                return;
            }

            writer.WriteNil();
        }

        public global::Nighthollow.Rules.RuleCondition Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            if (reader.ReadArrayHeader() != 2)
            {
                throw new InvalidOperationException("Invalid Union data was detected. Type:global::Nighthollow.Rules.RuleCondition");
            }

            options.Security.DepthStep(ref reader);
            var key = reader.ReadInt32();

            if (!this.keyToJumpMap.TryGetValue(key, out key))
            {
                key = -1;
            }

            global::Nighthollow.Rules.RuleCondition result = null;
            switch (key)
            {
                case 0:
                    result = (global::Nighthollow.Rules.RuleCondition)options.Resolver.GetFormatterWithVerify<global::Nighthollow.Rules.Conditions.UserDeckSizeCondition>().Deserialize(ref reader, options);
                    break;
                case 1:
                    result = (global::Nighthollow.Rules.RuleCondition)options.Resolver.GetFormatterWithVerify<global::Nighthollow.Rules.Conditions.HotkeyEqualsCondition>().Deserialize(ref reader, options);
                    break;
                default:
                    reader.Skip();
                    break;
            }

            reader.Depth--;
            return result;
        }
    }

    public sealed class RuleEffectFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Nighthollow.Rules.RuleEffect>
    {
        private readonly Dictionary<RuntimeTypeHandle, KeyValuePair<int, int>> typeToKeyAndJumpMap;
        private readonly Dictionary<int, int> keyToJumpMap;

        public RuleEffectFormatter()
        {
            this.typeToKeyAndJumpMap = new Dictionary<RuntimeTypeHandle, KeyValuePair<int, int>>(10, global::MessagePack.Internal.RuntimeTypeHandleEqualityComparer.Default)
            {
                { typeof(global::Nighthollow.Rules.Effects.DisplayHelpTextEffect).TypeHandle, new KeyValuePair<int, int>(0, 0) },
                { typeof(global::Nighthollow.Rules.Effects.CharacterDialogueEffect).TypeHandle, new KeyValuePair<int, int>(1, 1) },
                { typeof(global::Nighthollow.Rules.Effects.PreventDefaultEffect).TypeHandle, new KeyValuePair<int, int>(2, 2) },
                { typeof(global::Nighthollow.Rules.Effects.LoadSceneEffect).TypeHandle, new KeyValuePair<int, int>(3, 3) },
                { typeof(global::Nighthollow.Rules.Effects.InitializeWorldMapEffect).TypeHandle, new KeyValuePair<int, int>(4, 4) },
                { typeof(global::Nighthollow.Rules.Effects.CenterCameraOnHexEffect).TypeHandle, new KeyValuePair<int, int>(5, 5) },
                { typeof(global::Nighthollow.Rules.Effects.EnableAllRulesEffect).TypeHandle, new KeyValuePair<int, int>(6, 6) },
                { typeof(global::Nighthollow.Rules.Effects.PlaceCreaturesFromListEffect).TypeHandle, new KeyValuePair<int, int>(7, 7) },
                { typeof(global::Nighthollow.Rules.Effects.ClearScenariosEffect).TypeHandle, new KeyValuePair<int, int>(8, 8) },
                { typeof(global::Nighthollow.Rules.Effects.ResetToNewGameStateEffect).TypeHandle, new KeyValuePair<int, int>(9, 9) },
            };
            this.keyToJumpMap = new Dictionary<int, int>(10)
            {
                { 0, 0 },
                { 1, 1 },
                { 2, 2 },
                { 3, 3 },
                { 4, 4 },
                { 5, 5 },
                { 6, 6 },
                { 7, 7 },
                { 8, 8 },
                { 9, 9 },
            };
        }

        public void Serialize(ref MessagePackWriter writer, global::Nighthollow.Rules.RuleEffect value, global::MessagePack.MessagePackSerializerOptions options)
        {
            KeyValuePair<int, int> keyValuePair;
            if (value != null && this.typeToKeyAndJumpMap.TryGetValue(value.GetType().TypeHandle, out keyValuePair))
            {
                writer.WriteArrayHeader(2);
                writer.WriteInt32(keyValuePair.Key);
                switch (keyValuePair.Value)
                {
                    case 0:
                        options.Resolver.GetFormatterWithVerify<global::Nighthollow.Rules.Effects.DisplayHelpTextEffect>().Serialize(ref writer, (global::Nighthollow.Rules.Effects.DisplayHelpTextEffect)value, options);
                        break;
                    case 1:
                        options.Resolver.GetFormatterWithVerify<global::Nighthollow.Rules.Effects.CharacterDialogueEffect>().Serialize(ref writer, (global::Nighthollow.Rules.Effects.CharacterDialogueEffect)value, options);
                        break;
                    case 2:
                        options.Resolver.GetFormatterWithVerify<global::Nighthollow.Rules.Effects.PreventDefaultEffect>().Serialize(ref writer, (global::Nighthollow.Rules.Effects.PreventDefaultEffect)value, options);
                        break;
                    case 3:
                        options.Resolver.GetFormatterWithVerify<global::Nighthollow.Rules.Effects.LoadSceneEffect>().Serialize(ref writer, (global::Nighthollow.Rules.Effects.LoadSceneEffect)value, options);
                        break;
                    case 4:
                        options.Resolver.GetFormatterWithVerify<global::Nighthollow.Rules.Effects.InitializeWorldMapEffect>().Serialize(ref writer, (global::Nighthollow.Rules.Effects.InitializeWorldMapEffect)value, options);
                        break;
                    case 5:
                        options.Resolver.GetFormatterWithVerify<global::Nighthollow.Rules.Effects.CenterCameraOnHexEffect>().Serialize(ref writer, (global::Nighthollow.Rules.Effects.CenterCameraOnHexEffect)value, options);
                        break;
                    case 6:
                        options.Resolver.GetFormatterWithVerify<global::Nighthollow.Rules.Effects.EnableAllRulesEffect>().Serialize(ref writer, (global::Nighthollow.Rules.Effects.EnableAllRulesEffect)value, options);
                        break;
                    case 7:
                        options.Resolver.GetFormatterWithVerify<global::Nighthollow.Rules.Effects.PlaceCreaturesFromListEffect>().Serialize(ref writer, (global::Nighthollow.Rules.Effects.PlaceCreaturesFromListEffect)value, options);
                        break;
                    case 8:
                        options.Resolver.GetFormatterWithVerify<global::Nighthollow.Rules.Effects.ClearScenariosEffect>().Serialize(ref writer, (global::Nighthollow.Rules.Effects.ClearScenariosEffect)value, options);
                        break;
                    case 9:
                        options.Resolver.GetFormatterWithVerify<global::Nighthollow.Rules.Effects.ResetToNewGameStateEffect>().Serialize(ref writer, (global::Nighthollow.Rules.Effects.ResetToNewGameStateEffect)value, options);
                        break;
                    default:
                        break;
                }

                return;
            }

            writer.WriteNil();
        }

        public global::Nighthollow.Rules.RuleEffect Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            if (reader.ReadArrayHeader() != 2)
            {
                throw new InvalidOperationException("Invalid Union data was detected. Type:global::Nighthollow.Rules.RuleEffect");
            }

            options.Security.DepthStep(ref reader);
            var key = reader.ReadInt32();

            if (!this.keyToJumpMap.TryGetValue(key, out key))
            {
                key = -1;
            }

            global::Nighthollow.Rules.RuleEffect result = null;
            switch (key)
            {
                case 0:
                    result = (global::Nighthollow.Rules.RuleEffect)options.Resolver.GetFormatterWithVerify<global::Nighthollow.Rules.Effects.DisplayHelpTextEffect>().Deserialize(ref reader, options);
                    break;
                case 1:
                    result = (global::Nighthollow.Rules.RuleEffect)options.Resolver.GetFormatterWithVerify<global::Nighthollow.Rules.Effects.CharacterDialogueEffect>().Deserialize(ref reader, options);
                    break;
                case 2:
                    result = (global::Nighthollow.Rules.RuleEffect)options.Resolver.GetFormatterWithVerify<global::Nighthollow.Rules.Effects.PreventDefaultEffect>().Deserialize(ref reader, options);
                    break;
                case 3:
                    result = (global::Nighthollow.Rules.RuleEffect)options.Resolver.GetFormatterWithVerify<global::Nighthollow.Rules.Effects.LoadSceneEffect>().Deserialize(ref reader, options);
                    break;
                case 4:
                    result = (global::Nighthollow.Rules.RuleEffect)options.Resolver.GetFormatterWithVerify<global::Nighthollow.Rules.Effects.InitializeWorldMapEffect>().Deserialize(ref reader, options);
                    break;
                case 5:
                    result = (global::Nighthollow.Rules.RuleEffect)options.Resolver.GetFormatterWithVerify<global::Nighthollow.Rules.Effects.CenterCameraOnHexEffect>().Deserialize(ref reader, options);
                    break;
                case 6:
                    result = (global::Nighthollow.Rules.RuleEffect)options.Resolver.GetFormatterWithVerify<global::Nighthollow.Rules.Effects.EnableAllRulesEffect>().Deserialize(ref reader, options);
                    break;
                case 7:
                    result = (global::Nighthollow.Rules.RuleEffect)options.Resolver.GetFormatterWithVerify<global::Nighthollow.Rules.Effects.PlaceCreaturesFromListEffect>().Deserialize(ref reader, options);
                    break;
                case 8:
                    result = (global::Nighthollow.Rules.RuleEffect)options.Resolver.GetFormatterWithVerify<global::Nighthollow.Rules.Effects.ClearScenariosEffect>().Deserialize(ref reader, options);
                    break;
                case 9:
                    result = (global::Nighthollow.Rules.RuleEffect)options.Resolver.GetFormatterWithVerify<global::Nighthollow.Rules.Effects.ResetToNewGameStateEffect>().Deserialize(ref reader, options);
                    break;
                default:
                    reader.Skip();
                    break;
            }

            reader.Depth--;
            return result;
        }
    }


}

#pragma warning restore 168
#pragma warning restore 414
#pragma warning restore 618
#pragma warning restore 612

#pragma warning restore SA1200 // Using directives should be placed correctly
#pragma warning restore SA1403 // File may only contain a single namespace
#pragma warning restore SA1649 // File name should match first type name


// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY MPC(MessagePack-CSharp). DO NOT CHANGE IT.
// </auto-generated>

#pragma warning disable 618
#pragma warning disable 612
#pragma warning disable 414
#pragma warning disable 168

#pragma warning disable SA1129 // Do not use default value type constructor
#pragma warning disable SA1200 // Using directives should be placed correctly
#pragma warning disable SA1309 // Field names should not begin with underscore
#pragma warning disable SA1312 // Variable names should begin with lower-case letter
#pragma warning disable SA1403 // File may only contain a single namespace
#pragma warning disable SA1649 // File name should match first type name

namespace MessagePack.Formatters.Nighthollow.Components
{
    using System;
    using System.Buffers;
    using MessagePack;

    public sealed class GameDataHolderFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Nighthollow.Components.GameDataHolder>
    {

        public void Serialize(ref MessagePackWriter writer, global::Nighthollow.Components.GameDataHolder value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteArrayHeader(1);
            formatterResolver.GetFormatterWithVerify<global::System.Collections.Immutable.ImmutableDictionary<int, global::Nighthollow.Data.CreatureTypeData>>().Serialize(ref writer, value.Creatures, options);
        }

        public global::Nighthollow.Components.GameDataHolder Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadArrayHeader();
            var __Creatures__ = default(global::System.Collections.Immutable.ImmutableDictionary<int, global::Nighthollow.Data.CreatureTypeData>);

            for (int i = 0; i < length; i++)
            {
                switch (i)
                {
                    case 0:
                        __Creatures__ = formatterResolver.GetFormatterWithVerify<global::System.Collections.Immutable.ImmutableDictionary<int, global::Nighthollow.Data.CreatureTypeData>>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Nighthollow.Components.GameDataHolder(__Creatures__);
            reader.Depth--;
            return ____result;
        }
    }
}

#pragma warning restore 168
#pragma warning restore 414
#pragma warning restore 618
#pragma warning restore 612

#pragma warning restore SA1129 // Do not use default value type constructor
#pragma warning restore SA1200 // Using directives should be placed correctly
#pragma warning restore SA1309 // Field names should not begin with underscore
#pragma warning restore SA1312 // Variable names should begin with lower-case letter
#pragma warning restore SA1403 // File may only contain a single namespace
#pragma warning restore SA1649 // File name should match first type name

// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY MPC(MessagePack-CSharp). DO NOT CHANGE IT.
// </auto-generated>

#pragma warning disable 618
#pragma warning disable 612
#pragma warning disable 414
#pragma warning disable 168

#pragma warning disable SA1129 // Do not use default value type constructor
#pragma warning disable SA1200 // Using directives should be placed correctly
#pragma warning disable SA1309 // Field names should not begin with underscore
#pragma warning disable SA1312 // Variable names should begin with lower-case letter
#pragma warning disable SA1403 // File may only contain a single namespace
#pragma warning disable SA1649 // File name should match first type name

namespace MessagePack.Formatters.Nighthollow.Data
{
    using System;
    using System.Buffers;
    using MessagePack;

    public sealed class AffixDataFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Nighthollow.Data.AffixData>
    {

        public void Serialize(ref MessagePackWriter writer, global::Nighthollow.Data.AffixData value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteArrayHeader(2);
            writer.Write(value.AffixTypeId);
            formatterResolver.GetFormatterWithVerify<global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Data.ModifierData>>().Serialize(ref writer, value.Modifiers, options);
        }

        public global::Nighthollow.Data.AffixData Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadArrayHeader();
            var __AffixTypeId__ = default(int);
            var __Modifiers__ = default(global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Data.ModifierData>);

            for (int i = 0; i < length; i++)
            {
                switch (i)
                {
                    case 0:
                        __AffixTypeId__ = reader.ReadInt32();
                        break;
                    case 1:
                        __Modifiers__ = formatterResolver.GetFormatterWithVerify<global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Data.ModifierData>>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Nighthollow.Data.AffixData(__AffixTypeId__, __Modifiers__);
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class AffixTypeDataFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Nighthollow.Data.AffixTypeData>
    {

        public void Serialize(ref MessagePackWriter writer, global::Nighthollow.Data.AffixTypeData value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteArrayHeader(5);
            writer.Write(value.MinLevel);
            writer.Write(value.Weight);
            formatterResolver.GetFormatterWithVerify<global::Nighthollow.Stats.IntRangeValue>().Serialize(ref writer, value.ManaCost, options);
            formatterResolver.GetFormatterWithVerify<global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Data.ModifierData>>().Serialize(ref writer, value.Modifiers, options);
            formatterResolver.GetFormatterWithVerify<global::Nighthollow.Data.School?>().Serialize(ref writer, value.InfluenceType, options);
        }

        public global::Nighthollow.Data.AffixTypeData Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadArrayHeader();
            var __MinLevel__ = default(int);
            var __Weight__ = default(int);
            var __ManaCost__ = default(global::Nighthollow.Stats.IntRangeValue);
            var __Modifiers__ = default(global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Data.ModifierData>);
            var __InfluenceType__ = default(global::Nighthollow.Data.School?);

            for (int i = 0; i < length; i++)
            {
                switch (i)
                {
                    case 0:
                        __MinLevel__ = reader.ReadInt32();
                        break;
                    case 1:
                        __Weight__ = reader.ReadInt32();
                        break;
                    case 2:
                        __ManaCost__ = formatterResolver.GetFormatterWithVerify<global::Nighthollow.Stats.IntRangeValue>().Deserialize(ref reader, options);
                        break;
                    case 3:
                        __Modifiers__ = formatterResolver.GetFormatterWithVerify<global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Data.ModifierData>>().Deserialize(ref reader, options);
                        break;
                    case 4:
                        __InfluenceType__ = formatterResolver.GetFormatterWithVerify<global::Nighthollow.Data.School?>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Nighthollow.Data.AffixTypeData(__MinLevel__, __Weight__, __ManaCost__, __Modifiers__, __InfluenceType__);
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class BattleDataFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Nighthollow.Data.BattleData>
    {

        public void Serialize(ref MessagePackWriter writer, global::Nighthollow.Data.BattleData value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteArrayHeader(2);
            formatterResolver.GetFormatterWithVerify<global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Data.CreatureItemData>>().Serialize(ref writer, value.Enemies, options);
            formatterResolver.GetFormatterWithVerify<global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Data.ModifierData>>().Serialize(ref writer, value.EnemyModifiers, options);
        }

        public global::Nighthollow.Data.BattleData Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadArrayHeader();
            var __Enemies__ = default(global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Data.CreatureItemData>);
            var __EnemyModifiers__ = default(global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Data.ModifierData>);

            for (int i = 0; i < length; i++)
            {
                switch (i)
                {
                    case 0:
                        __Enemies__ = formatterResolver.GetFormatterWithVerify<global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Data.CreatureItemData>>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __EnemyModifiers__ = formatterResolver.GetFormatterWithVerify<global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Data.ModifierData>>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Nighthollow.Data.BattleData(__Enemies__, __EnemyModifiers__);
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class BoolValueDataFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Nighthollow.Data.BoolValueData>
    {

        public void Serialize(ref MessagePackWriter writer, global::Nighthollow.Data.BoolValueData value, global::MessagePack.MessagePackSerializerOptions options)
        {
            writer.WriteArrayHeader(1);
            writer.Write(value.Bool);
        }

        public global::Nighthollow.Data.BoolValueData Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                throw new InvalidOperationException("typecode is null, struct not supported");
            }

            options.Security.DepthStep(ref reader);
            var length = reader.ReadArrayHeader();
            var __Bool__ = default(bool);

            for (int i = 0; i < length; i++)
            {
                switch (i)
                {
                    case 0:
                        __Bool__ = reader.ReadBoolean();
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Nighthollow.Data.BoolValueData(__Bool__);
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class CreatureItemDataFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Nighthollow.Data.CreatureItemData>
    {

        public void Serialize(ref MessagePackWriter writer, global::Nighthollow.Data.CreatureItemData value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteArrayHeader(10);
            writer.Write(value.CreatureTypeId);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.Name, options);
            formatterResolver.GetFormatterWithVerify<global::Nighthollow.Data.School>().Serialize(ref writer, value.School, options);
            formatterResolver.GetFormatterWithVerify<global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Data.SkillItemData>>().Serialize(ref writer, value.Skills, options);
            formatterResolver.GetFormatterWithVerify<global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Data.AffixData>>().Serialize(ref writer, value.Affixes, options);
            formatterResolver.GetFormatterWithVerify<global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Data.ModifierData>>().Serialize(ref writer, value.ImplicitModifiers, options);
            writer.Write(value.Health);
            writer.Write(value.ManaCost);
            formatterResolver.GetFormatterWithVerify<global::Nighthollow.Data.ImmutableDictionaryValue<global::Nighthollow.Data.School, int>>().Serialize(ref writer, value.InfluenceCost, options);
            formatterResolver.GetFormatterWithVerify<global::Nighthollow.Data.ImmutableDictionaryValue<global::Nighthollow.Data.DamageType, global::Nighthollow.Stats.IntRangeValue>>().Serialize(ref writer, value.BaseDamage, options);
        }

        public global::Nighthollow.Data.CreatureItemData Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadArrayHeader();
            var __CreatureTypeId__ = default(int);
            var __Name__ = default(string);
            var __School__ = default(global::Nighthollow.Data.School);
            var __Skills__ = default(global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Data.SkillItemData>);
            var __Affixes__ = default(global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Data.AffixData>);
            var __ImplicitModifiers__ = default(global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Data.ModifierData>);
            var __Health__ = default(int);
            var __ManaCost__ = default(int);
            var __InfluenceCost__ = default(global::Nighthollow.Data.ImmutableDictionaryValue<global::Nighthollow.Data.School, int>);
            var __BaseDamage__ = default(global::Nighthollow.Data.ImmutableDictionaryValue<global::Nighthollow.Data.DamageType, global::Nighthollow.Stats.IntRangeValue>);

            for (int i = 0; i < length; i++)
            {
                switch (i)
                {
                    case 0:
                        __CreatureTypeId__ = reader.ReadInt32();
                        break;
                    case 1:
                        __Name__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 2:
                        __School__ = formatterResolver.GetFormatterWithVerify<global::Nighthollow.Data.School>().Deserialize(ref reader, options);
                        break;
                    case 3:
                        __Skills__ = formatterResolver.GetFormatterWithVerify<global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Data.SkillItemData>>().Deserialize(ref reader, options);
                        break;
                    case 4:
                        __Affixes__ = formatterResolver.GetFormatterWithVerify<global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Data.AffixData>>().Deserialize(ref reader, options);
                        break;
                    case 5:
                        __ImplicitModifiers__ = formatterResolver.GetFormatterWithVerify<global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Data.ModifierData>>().Deserialize(ref reader, options);
                        break;
                    case 6:
                        __Health__ = reader.ReadInt32();
                        break;
                    case 7:
                        __ManaCost__ = reader.ReadInt32();
                        break;
                    case 8:
                        __InfluenceCost__ = formatterResolver.GetFormatterWithVerify<global::Nighthollow.Data.ImmutableDictionaryValue<global::Nighthollow.Data.School, int>>().Deserialize(ref reader, options);
                        break;
                    case 9:
                        __BaseDamage__ = formatterResolver.GetFormatterWithVerify<global::Nighthollow.Data.ImmutableDictionaryValue<global::Nighthollow.Data.DamageType, global::Nighthollow.Stats.IntRangeValue>>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Nighthollow.Data.CreatureItemData(__CreatureTypeId__, __Name__, __School__, __Skills__, __Affixes__, __ImplicitModifiers__, __Health__, __ManaCost__, __InfluenceCost__, __BaseDamage__);
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class CreatureSkillAnimationFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Nighthollow.Data.CreatureSkillAnimation>
    {

        public void Serialize(ref MessagePackWriter writer, global::Nighthollow.Data.CreatureSkillAnimation value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteArrayHeader(4);
            formatterResolver.GetFormatterWithVerify<global::Nighthollow.Data.SkillAnimationNumber>().Serialize(ref writer, value.SkillAnimationNumber, options);
            formatterResolver.GetFormatterWithVerify<global::Nighthollow.Data.SkillAnimationType>().Serialize(ref writer, value.SkillAnimationType, options);
            formatterResolver.GetFormatterWithVerify<global::Nighthollow.Stats.DurationValue?>().Serialize(ref writer, value.Duration, options);
            formatterResolver.GetFormatterWithVerify<int?>().Serialize(ref writer, value.SkillTypeId, options);
        }

        public global::Nighthollow.Data.CreatureSkillAnimation Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadArrayHeader();
            var __SkillAnimationNumber__ = default(global::Nighthollow.Data.SkillAnimationNumber);
            var __SkillAnimationType__ = default(global::Nighthollow.Data.SkillAnimationType);
            var __Duration__ = default(global::Nighthollow.Stats.DurationValue?);
            var __SkillTypeId__ = default(int?);

            for (int i = 0; i < length; i++)
            {
                switch (i)
                {
                    case 0:
                        __SkillAnimationNumber__ = formatterResolver.GetFormatterWithVerify<global::Nighthollow.Data.SkillAnimationNumber>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __SkillAnimationType__ = formatterResolver.GetFormatterWithVerify<global::Nighthollow.Data.SkillAnimationType>().Deserialize(ref reader, options);
                        break;
                    case 2:
                        __Duration__ = formatterResolver.GetFormatterWithVerify<global::Nighthollow.Stats.DurationValue?>().Deserialize(ref reader, options);
                        break;
                    case 3:
                        __SkillTypeId__ = formatterResolver.GetFormatterWithVerify<int?>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Nighthollow.Data.CreatureSkillAnimation(__SkillAnimationNumber__, __SkillAnimationType__, __Duration__, __SkillTypeId__);
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class CreatureTypeDataFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Nighthollow.Data.CreatureTypeData>
    {

        public void Serialize(ref MessagePackWriter writer, global::Nighthollow.Data.CreatureTypeData value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteArrayHeader(10);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.Name, options);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.PrefabAddress, options);
            formatterResolver.GetFormatterWithVerify<global::Nighthollow.Data.PlayerName>().Serialize(ref writer, value.Owner, options);
            formatterResolver.GetFormatterWithVerify<global::Nighthollow.Stats.IntRangeValue>().Serialize(ref writer, value.Health, options);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.ImageAddress, options);
            writer.Write(value.BaseManaCost);
            writer.Write(value.Speed);
            formatterResolver.GetFormatterWithVerify<global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Data.ModifierData>>().Serialize(ref writer, value.ImplicitModifiers, options);
            formatterResolver.GetFormatterWithVerify<global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Data.CreatureSkillAnimation>>().Serialize(ref writer, value.SkillAnimations, options);
            writer.Write(value.IsManaCreature);
        }

        public global::Nighthollow.Data.CreatureTypeData Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadArrayHeader();
            var __Name__ = default(string);
            var __PrefabAddress__ = default(string);
            var __Owner__ = default(global::Nighthollow.Data.PlayerName);
            var __Health__ = default(global::Nighthollow.Stats.IntRangeValue);
            var __ImageAddress__ = default(string);
            var __BaseManaCost__ = default(int);
            var __Speed__ = default(int);
            var __ImplicitModifiers__ = default(global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Data.ModifierData>);
            var __SkillAnimations__ = default(global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Data.CreatureSkillAnimation>);
            var __IsManaCreature__ = default(bool);

            for (int i = 0; i < length; i++)
            {
                switch (i)
                {
                    case 0:
                        __Name__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __PrefabAddress__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 2:
                        __Owner__ = formatterResolver.GetFormatterWithVerify<global::Nighthollow.Data.PlayerName>().Deserialize(ref reader, options);
                        break;
                    case 3:
                        __Health__ = formatterResolver.GetFormatterWithVerify<global::Nighthollow.Stats.IntRangeValue>().Deserialize(ref reader, options);
                        break;
                    case 4:
                        __ImageAddress__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 5:
                        __BaseManaCost__ = reader.ReadInt32();
                        break;
                    case 6:
                        __Speed__ = reader.ReadInt32();
                        break;
                    case 7:
                        __ImplicitModifiers__ = formatterResolver.GetFormatterWithVerify<global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Data.ModifierData>>().Deserialize(ref reader, options);
                        break;
                    case 8:
                        __SkillAnimations__ = formatterResolver.GetFormatterWithVerify<global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Data.CreatureSkillAnimation>>().Deserialize(ref reader, options);
                        break;
                    case 9:
                        __IsManaCreature__ = reader.ReadBoolean();
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Nighthollow.Data.CreatureTypeData(__Name__, __PrefabAddress__, __Owner__, __Health__, __ImageAddress__, __BaseManaCost__, __Speed__, __ImplicitModifiers__, __SkillAnimations__, __IsManaCreature__);
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class GlobalDataFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Nighthollow.Data.GlobalData>
    {

        public void Serialize(ref MessagePackWriter writer, global::Nighthollow.Data.GlobalData value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteArrayHeader(3);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.Name, options);
            writer.Write(value.Value);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.Comment, options);
        }

        public global::Nighthollow.Data.GlobalData Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadArrayHeader();
            var __Name__ = default(string);
            var __Value__ = default(int);
            var __Comment__ = default(string);

            for (int i = 0; i < length; i++)
            {
                switch (i)
                {
                    case 0:
                        __Name__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __Value__ = reader.ReadInt32();
                        break;
                    case 2:
                        __Comment__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Nighthollow.Data.GlobalData(__Name__, __Value__, __Comment__);
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class ImmutableDictionaryValueFormatter<TTag,TValue> : global::MessagePack.Formatters.IMessagePackFormatter<global::Nighthollow.Data.ImmutableDictionaryValue<TTag, TValue>>
        where TTag : notnull
    {

        public void Serialize(ref MessagePackWriter writer, global::Nighthollow.Data.ImmutableDictionaryValue<TTag, TValue> value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteArrayHeader(1);
            formatterResolver.GetFormatterWithVerify<global::System.Collections.Immutable.ImmutableDictionary<TTag, TValue>>().Serialize(ref writer, value.Dictionary, options);
        }

        public global::Nighthollow.Data.ImmutableDictionaryValue<TTag, TValue> Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadArrayHeader();
            var __Dictionary__ = default(global::System.Collections.Immutable.ImmutableDictionary<TTag, TValue>);

            for (int i = 0; i < length; i++)
            {
                switch (i)
                {
                    case 0:
                        __Dictionary__ = formatterResolver.GetFormatterWithVerify<global::System.Collections.Immutable.ImmutableDictionary<TTag, TValue>>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Nighthollow.Data.ImmutableDictionaryValue<TTag, TValue>(__Dictionary__);
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class IntValueDataFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Nighthollow.Data.IntValueData>
    {

        public void Serialize(ref MessagePackWriter writer, global::Nighthollow.Data.IntValueData value, global::MessagePack.MessagePackSerializerOptions options)
        {
            writer.WriteArrayHeader(1);
            writer.Write(value.Int);
        }

        public global::Nighthollow.Data.IntValueData Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                throw new InvalidOperationException("typecode is null, struct not supported");
            }

            options.Security.DepthStep(ref reader);
            var length = reader.ReadArrayHeader();
            var __Int__ = default(int);

            for (int i = 0; i < length; i++)
            {
                switch (i)
                {
                    case 0:
                        __Int__ = reader.ReadInt32();
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Nighthollow.Data.IntValueData(__Int__);
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class ModifierDataFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Nighthollow.Data.ModifierData>
    {

        public void Serialize(ref MessagePackWriter writer, global::Nighthollow.Data.ModifierData value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteArrayHeader(7);
            formatterResolver.GetFormatterWithVerify<global::Nighthollow.Stats.StatId?>().Serialize(ref writer, value.StatId, options);
            formatterResolver.GetFormatterWithVerify<global::Nighthollow.Stats.ModifierType?>().Serialize(ref writer, value.ModifierType, options);
            formatterResolver.GetFormatterWithVerify<global::Nighthollow.Delegates.DelegateId?>().Serialize(ref writer, value.DelegateId, options);
            formatterResolver.GetFormatterWithVerify<global::Nighthollow.Data.IValueData>().Serialize(ref writer, value.Value, options);
            formatterResolver.GetFormatterWithVerify<global::Nighthollow.Data.IValueData>().Serialize(ref writer, value.ValueLow, options);
            formatterResolver.GetFormatterWithVerify<global::Nighthollow.Data.IValueData>().Serialize(ref writer, value.ValueHigh, options);
            writer.Write(value.Targeted);
        }

        public global::Nighthollow.Data.ModifierData Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadArrayHeader();
            var __StatId__ = default(global::Nighthollow.Stats.StatId?);
            var __ModifierType__ = default(global::Nighthollow.Stats.ModifierType?);
            var __DelegateId__ = default(global::Nighthollow.Delegates.DelegateId?);
            var __Value__ = default(global::Nighthollow.Data.IValueData);
            var __ValueLow__ = default(global::Nighthollow.Data.IValueData);
            var __ValueHigh__ = default(global::Nighthollow.Data.IValueData);
            var __Targeted__ = default(bool);

            for (int i = 0; i < length; i++)
            {
                switch (i)
                {
                    case 0:
                        __StatId__ = formatterResolver.GetFormatterWithVerify<global::Nighthollow.Stats.StatId?>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __ModifierType__ = formatterResolver.GetFormatterWithVerify<global::Nighthollow.Stats.ModifierType?>().Deserialize(ref reader, options);
                        break;
                    case 2:
                        __DelegateId__ = formatterResolver.GetFormatterWithVerify<global::Nighthollow.Delegates.DelegateId?>().Deserialize(ref reader, options);
                        break;
                    case 3:
                        __Value__ = formatterResolver.GetFormatterWithVerify<global::Nighthollow.Data.IValueData>().Deserialize(ref reader, options);
                        break;
                    case 4:
                        __ValueLow__ = formatterResolver.GetFormatterWithVerify<global::Nighthollow.Data.IValueData>().Deserialize(ref reader, options);
                        break;
                    case 5:
                        __ValueHigh__ = formatterResolver.GetFormatterWithVerify<global::Nighthollow.Data.IValueData>().Deserialize(ref reader, options);
                        break;
                    case 6:
                        __Targeted__ = reader.ReadBoolean();
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Nighthollow.Data.ModifierData(__StatId__, __ModifierType__, __DelegateId__, __Value__, __ValueLow__, __ValueHigh__, __Targeted__);
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class ResourceItemDataFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Nighthollow.Data.ResourceItemData>
    {

        public void Serialize(ref MessagePackWriter writer, global::Nighthollow.Data.ResourceItemData value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteArrayHeader(3);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.Name, options);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.ImageAddress, options);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.Description, options);
        }

        public global::Nighthollow.Data.ResourceItemData Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadArrayHeader();
            var __Name__ = default(string);
            var __ImageAddress__ = default(string);
            var __Description__ = default(string);

            for (int i = 0; i < length; i++)
            {
                switch (i)
                {
                    case 0:
                        __Name__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __ImageAddress__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 2:
                        __Description__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Nighthollow.Data.ResourceItemData(__Name__, __ImageAddress__, __Description__);
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class SerializationListFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Nighthollow.Data.SerializationList>
    {

        public void Serialize(ref MessagePackWriter writer, global::Nighthollow.Data.SerializationList value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteArrayHeader(110);
            formatterResolver.GetFormatterWithVerify<global::System.Collections.Immutable.ImmutableDictionary<int, global::Nighthollow.Data.TableMetadata>>().Serialize(ref writer, value.TableMetadata, options);
            formatterResolver.GetFormatterWithVerify<global::System.Collections.Immutable.ImmutableDictionary<int, global::Nighthollow.Data.CreatureTypeData>>().Serialize(ref writer, value.CreatureTypes, options);
            formatterResolver.GetFormatterWithVerify<global::System.Collections.Immutable.ImmutableDictionary<int, global::Nighthollow.Data.AffixTypeData>>().Serialize(ref writer, value.AffixTypes, options);
            formatterResolver.GetFormatterWithVerify<global::System.Collections.Immutable.ImmutableDictionary<int, global::Nighthollow.Data.SkillTypeData>>().Serialize(ref writer, value.SkillTypes, options);
            formatterResolver.GetFormatterWithVerify<global::System.Collections.Immutable.ImmutableDictionary<int, global::Nighthollow.Data.StatData>>().Serialize(ref writer, value.StatData, options);
            formatterResolver.GetFormatterWithVerify<global::System.Collections.Immutable.ImmutableDictionary<int, global::Nighthollow.Data.StaticItemListData>>().Serialize(ref writer, value.ItemLists, options);
            formatterResolver.GetFormatterWithVerify<global::System.Collections.Immutable.ImmutableDictionary<int, global::Nighthollow.Data.ModifierData>>().Serialize(ref writer, value.UserModifiers, options);
            formatterResolver.GetFormatterWithVerify<global::System.Collections.Immutable.ImmutableDictionary<int, global::Nighthollow.Data.CreatureItemData>>().Serialize(ref writer, value.Collection, options);
            formatterResolver.GetFormatterWithVerify<global::System.Collections.Immutable.ImmutableDictionary<int, global::Nighthollow.Data.CreatureItemData>>().Serialize(ref writer, value.Deck, options);
            formatterResolver.GetFormatterWithVerify<global::Nighthollow.Data.BattleData>().Serialize(ref writer, value.BattleData, options);
            formatterResolver.GetFormatterWithVerify<global::System.Collections.Immutable.ImmutableDictionary<int, global::Nighthollow.Data.StatusEffectTypeData>>().Serialize(ref writer, value.StatusEffects, options);
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            formatterResolver.GetFormatterWithVerify<global::Nighthollow.Data.IntValueData>().Serialize(ref writer, value.A, options);
            formatterResolver.GetFormatterWithVerify<global::Nighthollow.Stats.DurationValue>().Serialize(ref writer, value.B, options);
            formatterResolver.GetFormatterWithVerify<global::Nighthollow.Stats.PercentageValue>().Serialize(ref writer, value.C, options);
            writer.WriteNil();
            formatterResolver.GetFormatterWithVerify<global::Nighthollow.Stats.IntRangeValue>().Serialize(ref writer, value.D, options);
            formatterResolver.GetFormatterWithVerify<global::Nighthollow.Data.BoolValueData>().Serialize(ref writer, value.E, options);
            formatterResolver.GetFormatterWithVerify<global::Nighthollow.Data.ImmutableDictionaryValue<global::Nighthollow.Data.DamageType, int>>().Serialize(ref writer, value.F, options);
            formatterResolver.GetFormatterWithVerify<global::Nighthollow.Data.ImmutableDictionaryValue<global::Nighthollow.Data.DamageType, global::Nighthollow.Stats.PercentageValue>>().Serialize(ref writer, value.G, options);
            formatterResolver.GetFormatterWithVerify<global::Nighthollow.Data.ImmutableDictionaryValue<global::Nighthollow.Data.DamageType, global::Nighthollow.Stats.IntRangeValue>>().Serialize(ref writer, value.H, options);
            formatterResolver.GetFormatterWithVerify<global::Nighthollow.Data.ImmutableDictionaryValue<global::Nighthollow.Data.School, int>>().Serialize(ref writer, value.I, options);
        }

        public global::Nighthollow.Data.SerializationList Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadArrayHeader();
            var __TableMetadata__ = default(global::System.Collections.Immutable.ImmutableDictionary<int, global::Nighthollow.Data.TableMetadata>);
            var __CreatureTypes__ = default(global::System.Collections.Immutable.ImmutableDictionary<int, global::Nighthollow.Data.CreatureTypeData>);
            var __AffixTypes__ = default(global::System.Collections.Immutable.ImmutableDictionary<int, global::Nighthollow.Data.AffixTypeData>);
            var __SkillTypes__ = default(global::System.Collections.Immutable.ImmutableDictionary<int, global::Nighthollow.Data.SkillTypeData>);
            var __StatData__ = default(global::System.Collections.Immutable.ImmutableDictionary<int, global::Nighthollow.Data.StatData>);
            var __ItemLists__ = default(global::System.Collections.Immutable.ImmutableDictionary<int, global::Nighthollow.Data.StaticItemListData>);
            var __UserModifiers__ = default(global::System.Collections.Immutable.ImmutableDictionary<int, global::Nighthollow.Data.ModifierData>);
            var __Collection__ = default(global::System.Collections.Immutable.ImmutableDictionary<int, global::Nighthollow.Data.CreatureItemData>);
            var __Deck__ = default(global::System.Collections.Immutable.ImmutableDictionary<int, global::Nighthollow.Data.CreatureItemData>);
            var __BattleData__ = default(global::Nighthollow.Data.BattleData);
            var __StatusEffects__ = default(global::System.Collections.Immutable.ImmutableDictionary<int, global::Nighthollow.Data.StatusEffectTypeData>);
            var __A__ = default(global::Nighthollow.Data.IntValueData);
            var __B__ = default(global::Nighthollow.Stats.DurationValue);
            var __C__ = default(global::Nighthollow.Stats.PercentageValue);
            var __D__ = default(global::Nighthollow.Stats.IntRangeValue);
            var __E__ = default(global::Nighthollow.Data.BoolValueData);
            var __F__ = default(global::Nighthollow.Data.ImmutableDictionaryValue<global::Nighthollow.Data.DamageType, int>);
            var __G__ = default(global::Nighthollow.Data.ImmutableDictionaryValue<global::Nighthollow.Data.DamageType, global::Nighthollow.Stats.PercentageValue>);
            var __H__ = default(global::Nighthollow.Data.ImmutableDictionaryValue<global::Nighthollow.Data.DamageType, global::Nighthollow.Stats.IntRangeValue>);
            var __I__ = default(global::Nighthollow.Data.ImmutableDictionaryValue<global::Nighthollow.Data.School, int>);

            for (int i = 0; i < length; i++)
            {
                switch (i)
                {
                    case 0:
                        __TableMetadata__ = formatterResolver.GetFormatterWithVerify<global::System.Collections.Immutable.ImmutableDictionary<int, global::Nighthollow.Data.TableMetadata>>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __CreatureTypes__ = formatterResolver.GetFormatterWithVerify<global::System.Collections.Immutable.ImmutableDictionary<int, global::Nighthollow.Data.CreatureTypeData>>().Deserialize(ref reader, options);
                        break;
                    case 2:
                        __AffixTypes__ = formatterResolver.GetFormatterWithVerify<global::System.Collections.Immutable.ImmutableDictionary<int, global::Nighthollow.Data.AffixTypeData>>().Deserialize(ref reader, options);
                        break;
                    case 3:
                        __SkillTypes__ = formatterResolver.GetFormatterWithVerify<global::System.Collections.Immutable.ImmutableDictionary<int, global::Nighthollow.Data.SkillTypeData>>().Deserialize(ref reader, options);
                        break;
                    case 4:
                        __StatData__ = formatterResolver.GetFormatterWithVerify<global::System.Collections.Immutable.ImmutableDictionary<int, global::Nighthollow.Data.StatData>>().Deserialize(ref reader, options);
                        break;
                    case 5:
                        __ItemLists__ = formatterResolver.GetFormatterWithVerify<global::System.Collections.Immutable.ImmutableDictionary<int, global::Nighthollow.Data.StaticItemListData>>().Deserialize(ref reader, options);
                        break;
                    case 6:
                        __UserModifiers__ = formatterResolver.GetFormatterWithVerify<global::System.Collections.Immutable.ImmutableDictionary<int, global::Nighthollow.Data.ModifierData>>().Deserialize(ref reader, options);
                        break;
                    case 7:
                        __Collection__ = formatterResolver.GetFormatterWithVerify<global::System.Collections.Immutable.ImmutableDictionary<int, global::Nighthollow.Data.CreatureItemData>>().Deserialize(ref reader, options);
                        break;
                    case 8:
                        __Deck__ = formatterResolver.GetFormatterWithVerify<global::System.Collections.Immutable.ImmutableDictionary<int, global::Nighthollow.Data.CreatureItemData>>().Deserialize(ref reader, options);
                        break;
                    case 9:
                        __BattleData__ = formatterResolver.GetFormatterWithVerify<global::Nighthollow.Data.BattleData>().Deserialize(ref reader, options);
                        break;
                    case 10:
                        __StatusEffects__ = formatterResolver.GetFormatterWithVerify<global::System.Collections.Immutable.ImmutableDictionary<int, global::Nighthollow.Data.StatusEffectTypeData>>().Deserialize(ref reader, options);
                        break;
                    case 100:
                        __A__ = formatterResolver.GetFormatterWithVerify<global::Nighthollow.Data.IntValueData>().Deserialize(ref reader, options);
                        break;
                    case 101:
                        __B__ = formatterResolver.GetFormatterWithVerify<global::Nighthollow.Stats.DurationValue>().Deserialize(ref reader, options);
                        break;
                    case 102:
                        __C__ = formatterResolver.GetFormatterWithVerify<global::Nighthollow.Stats.PercentageValue>().Deserialize(ref reader, options);
                        break;
                    case 104:
                        __D__ = formatterResolver.GetFormatterWithVerify<global::Nighthollow.Stats.IntRangeValue>().Deserialize(ref reader, options);
                        break;
                    case 105:
                        __E__ = formatterResolver.GetFormatterWithVerify<global::Nighthollow.Data.BoolValueData>().Deserialize(ref reader, options);
                        break;
                    case 106:
                        __F__ = formatterResolver.GetFormatterWithVerify<global::Nighthollow.Data.ImmutableDictionaryValue<global::Nighthollow.Data.DamageType, int>>().Deserialize(ref reader, options);
                        break;
                    case 107:
                        __G__ = formatterResolver.GetFormatterWithVerify<global::Nighthollow.Data.ImmutableDictionaryValue<global::Nighthollow.Data.DamageType, global::Nighthollow.Stats.PercentageValue>>().Deserialize(ref reader, options);
                        break;
                    case 108:
                        __H__ = formatterResolver.GetFormatterWithVerify<global::Nighthollow.Data.ImmutableDictionaryValue<global::Nighthollow.Data.DamageType, global::Nighthollow.Stats.IntRangeValue>>().Deserialize(ref reader, options);
                        break;
                    case 109:
                        __I__ = formatterResolver.GetFormatterWithVerify<global::Nighthollow.Data.ImmutableDictionaryValue<global::Nighthollow.Data.School, int>>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Nighthollow.Data.SerializationList();
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class SkillItemDataFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Nighthollow.Data.SkillItemData>
    {

        public void Serialize(ref MessagePackWriter writer, global::Nighthollow.Data.SkillItemData value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteArrayHeader(7);
            writer.Write(value.SkillTypeId);
            formatterResolver.GetFormatterWithVerify<global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Data.AffixData>>().Serialize(ref writer, value.Affixes, options);
            formatterResolver.GetFormatterWithVerify<global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Data.ModifierData>>().Serialize(ref writer, value.ImplicitModifiers, options);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.Name, options);
            formatterResolver.GetFormatterWithVerify<global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Data.CreatureItemData>>().Serialize(ref writer, value.Summons, options);
            formatterResolver.GetFormatterWithVerify<global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Data.StatusEffectItemData>>().Serialize(ref writer, value.StatusEffects, options);
            formatterResolver.GetFormatterWithVerify<global::Nighthollow.Stats.DurationValue?>().Serialize(ref writer, value.Cooldown, options);
        }

        public global::Nighthollow.Data.SkillItemData Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadArrayHeader();
            var __SkillTypeId__ = default(int);
            var __Affixes__ = default(global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Data.AffixData>);
            var __ImplicitModifiers__ = default(global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Data.ModifierData>);
            var __Name__ = default(string);
            var __Summons__ = default(global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Data.CreatureItemData>);
            var __StatusEffects__ = default(global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Data.StatusEffectItemData>);
            var __Cooldown__ = default(global::Nighthollow.Stats.DurationValue?);

            for (int i = 0; i < length; i++)
            {
                switch (i)
                {
                    case 0:
                        __SkillTypeId__ = reader.ReadInt32();
                        break;
                    case 1:
                        __Affixes__ = formatterResolver.GetFormatterWithVerify<global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Data.AffixData>>().Deserialize(ref reader, options);
                        break;
                    case 2:
                        __ImplicitModifiers__ = formatterResolver.GetFormatterWithVerify<global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Data.ModifierData>>().Deserialize(ref reader, options);
                        break;
                    case 3:
                        __Name__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 4:
                        __Summons__ = formatterResolver.GetFormatterWithVerify<global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Data.CreatureItemData>>().Deserialize(ref reader, options);
                        break;
                    case 5:
                        __StatusEffects__ = formatterResolver.GetFormatterWithVerify<global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Data.StatusEffectItemData>>().Deserialize(ref reader, options);
                        break;
                    case 6:
                        __Cooldown__ = formatterResolver.GetFormatterWithVerify<global::Nighthollow.Stats.DurationValue?>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Nighthollow.Data.SkillItemData(__SkillTypeId__, __Affixes__, __ImplicitModifiers__, __Name__, __Summons__, __StatusEffects__, __Cooldown__);
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class SkillTypeDataFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Nighthollow.Data.SkillTypeData>
    {

        public void Serialize(ref MessagePackWriter writer, global::Nighthollow.Data.SkillTypeData value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteArrayHeader(13);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.Name, options);
            formatterResolver.GetFormatterWithVerify<global::Nighthollow.Data.SkillAnimationType>().Serialize(ref writer, value.SkillAnimationType, options);
            formatterResolver.GetFormatterWithVerify<global::Nighthollow.Data.SkillType>().Serialize(ref writer, value.SkillType, options);
            formatterResolver.GetFormatterWithVerify<global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Data.ModifierData>>().Serialize(ref writer, value.ImplicitModifiers, options);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.Address, options);
            formatterResolver.GetFormatterWithVerify<int?>().Serialize(ref writer, value.ProjectileSpeed, options);
            writer.Write(value.UsesAccuracy);
            writer.Write(value.CanCrit);
            writer.Write(value.CanStun);
            formatterResolver.GetFormatterWithVerify<global::System.Collections.Immutable.ImmutableList<int>>().Serialize(ref writer, value.SummonCreatures, options);
            formatterResolver.GetFormatterWithVerify<global::System.Collections.Immutable.ImmutableList<int>>().Serialize(ref writer, value.StatusEffects, options);
            formatterResolver.GetFormatterWithVerify<global::Nighthollow.Stats.DurationValue?>().Serialize(ref writer, value.Cooldown, options);
            formatterResolver.GetFormatterWithVerify<global::Nighthollow.Stats.DurationValue?>().Serialize(ref writer, value.CooldownHigh, options);
        }

        public global::Nighthollow.Data.SkillTypeData Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadArrayHeader();
            var __Name__ = default(string);
            var __SkillAnimationType__ = default(global::Nighthollow.Data.SkillAnimationType);
            var __SkillType__ = default(global::Nighthollow.Data.SkillType);
            var __ImplicitModifiers__ = default(global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Data.ModifierData>);
            var __Address__ = default(string);
            var __ProjectileSpeed__ = default(int?);
            var __UsesAccuracy__ = default(bool);
            var __CanCrit__ = default(bool);
            var __CanStun__ = default(bool);
            var __SummonCreatures__ = default(global::System.Collections.Immutable.ImmutableList<int>);
            var __StatusEffects__ = default(global::System.Collections.Immutable.ImmutableList<int>);
            var __Cooldown__ = default(global::Nighthollow.Stats.DurationValue?);
            var __CooldownHigh__ = default(global::Nighthollow.Stats.DurationValue?);

            for (int i = 0; i < length; i++)
            {
                switch (i)
                {
                    case 0:
                        __Name__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __SkillAnimationType__ = formatterResolver.GetFormatterWithVerify<global::Nighthollow.Data.SkillAnimationType>().Deserialize(ref reader, options);
                        break;
                    case 2:
                        __SkillType__ = formatterResolver.GetFormatterWithVerify<global::Nighthollow.Data.SkillType>().Deserialize(ref reader, options);
                        break;
                    case 3:
                        __ImplicitModifiers__ = formatterResolver.GetFormatterWithVerify<global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Data.ModifierData>>().Deserialize(ref reader, options);
                        break;
                    case 4:
                        __Address__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 5:
                        __ProjectileSpeed__ = formatterResolver.GetFormatterWithVerify<int?>().Deserialize(ref reader, options);
                        break;
                    case 6:
                        __UsesAccuracy__ = reader.ReadBoolean();
                        break;
                    case 7:
                        __CanCrit__ = reader.ReadBoolean();
                        break;
                    case 8:
                        __CanStun__ = reader.ReadBoolean();
                        break;
                    case 9:
                        __SummonCreatures__ = formatterResolver.GetFormatterWithVerify<global::System.Collections.Immutable.ImmutableList<int>>().Deserialize(ref reader, options);
                        break;
                    case 10:
                        __StatusEffects__ = formatterResolver.GetFormatterWithVerify<global::System.Collections.Immutable.ImmutableList<int>>().Deserialize(ref reader, options);
                        break;
                    case 11:
                        __Cooldown__ = formatterResolver.GetFormatterWithVerify<global::Nighthollow.Stats.DurationValue?>().Deserialize(ref reader, options);
                        break;
                    case 12:
                        __CooldownHigh__ = formatterResolver.GetFormatterWithVerify<global::Nighthollow.Stats.DurationValue?>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Nighthollow.Data.SkillTypeData(__Name__, __SkillAnimationType__, __SkillType__, __ImplicitModifiers__, __Address__, __ProjectileSpeed__, __UsesAccuracy__, __CanCrit__, __CanStun__, __SummonCreatures__, __StatusEffects__, __Cooldown__, __CooldownHigh__);
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class StatDataFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Nighthollow.Data.StatData>
    {

        public void Serialize(ref MessagePackWriter writer, global::Nighthollow.Data.StatData value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteArrayHeader(7);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.Name, options);
            formatterResolver.GetFormatterWithVerify<global::Nighthollow.Data.StatType>().Serialize(ref writer, value.StatType, options);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.DescriptionTemplate, options);
            formatterResolver.GetFormatterWithVerify<global::Nighthollow.Data.IValueData>().Serialize(ref writer, value.DefaultValue, options);
            formatterResolver.GetFormatterWithVerify<global::Nighthollow.Data.StatTagType?>().Serialize(ref writer, value.TagType, options);
            formatterResolver.GetFormatterWithVerify<global::Nighthollow.Data.StatType?>().Serialize(ref writer, value.StatValueType, options);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.Comment, options);
        }

        public global::Nighthollow.Data.StatData Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadArrayHeader();
            var __Name__ = default(string);
            var __StatType__ = default(global::Nighthollow.Data.StatType);
            var __DescriptionTemplate__ = default(string);
            var __DefaultValue__ = default(global::Nighthollow.Data.IValueData);
            var __TagType__ = default(global::Nighthollow.Data.StatTagType?);
            var __StatValueType__ = default(global::Nighthollow.Data.StatType?);
            var __Comment__ = default(string);

            for (int i = 0; i < length; i++)
            {
                switch (i)
                {
                    case 0:
                        __Name__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __StatType__ = formatterResolver.GetFormatterWithVerify<global::Nighthollow.Data.StatType>().Deserialize(ref reader, options);
                        break;
                    case 2:
                        __DescriptionTemplate__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 3:
                        __DefaultValue__ = formatterResolver.GetFormatterWithVerify<global::Nighthollow.Data.IValueData>().Deserialize(ref reader, options);
                        break;
                    case 4:
                        __TagType__ = formatterResolver.GetFormatterWithVerify<global::Nighthollow.Data.StatTagType?>().Deserialize(ref reader, options);
                        break;
                    case 5:
                        __StatValueType__ = formatterResolver.GetFormatterWithVerify<global::Nighthollow.Data.StatType?>().Deserialize(ref reader, options);
                        break;
                    case 6:
                        __Comment__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Nighthollow.Data.StatData(__Name__, __StatType__, __DescriptionTemplate__, __DefaultValue__, __TagType__, __StatValueType__, __Comment__);
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class StaticItemListDataFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Nighthollow.Data.StaticItemListData>
    {

        public void Serialize(ref MessagePackWriter writer, global::Nighthollow.Data.StaticItemListData value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteArrayHeader(4);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.Name, options);
            formatterResolver.GetFormatterWithVerify<global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Data.CreatureItemData>>().Serialize(ref writer, value.Creatures, options);
            formatterResolver.GetFormatterWithVerify<global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Data.ResourceItemData>>().Serialize(ref writer, value.Resources, options);
            formatterResolver.GetFormatterWithVerify<global::Nighthollow.Data.StaticItemListData.IdentifierTag>().Serialize(ref writer, value.Tag, options);
        }

        public global::Nighthollow.Data.StaticItemListData Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadArrayHeader();
            var __Name__ = default(string);
            var __Creatures__ = default(global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Data.CreatureItemData>);
            var __Resources__ = default(global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Data.ResourceItemData>);
            var __Tag__ = default(global::Nighthollow.Data.StaticItemListData.IdentifierTag);

            for (int i = 0; i < length; i++)
            {
                switch (i)
                {
                    case 0:
                        __Name__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __Creatures__ = formatterResolver.GetFormatterWithVerify<global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Data.CreatureItemData>>().Deserialize(ref reader, options);
                        break;
                    case 2:
                        __Resources__ = formatterResolver.GetFormatterWithVerify<global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Data.ResourceItemData>>().Deserialize(ref reader, options);
                        break;
                    case 3:
                        __Tag__ = formatterResolver.GetFormatterWithVerify<global::Nighthollow.Data.StaticItemListData.IdentifierTag>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Nighthollow.Data.StaticItemListData(__Name__, __Creatures__, __Resources__, __Tag__);
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class StatusEffectItemDataFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Nighthollow.Data.StatusEffectItemData>
    {

        public void Serialize(ref MessagePackWriter writer, global::Nighthollow.Data.StatusEffectItemData value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteArrayHeader(3);
            writer.Write(value.StatusEffectTypeId);
            formatterResolver.GetFormatterWithVerify<global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Data.ModifierData>>().Serialize(ref writer, value.ImplicitModifiers, options);
            formatterResolver.GetFormatterWithVerify<global::Nighthollow.Stats.DurationValue?>().Serialize(ref writer, value.Duration, options);
        }

        public global::Nighthollow.Data.StatusEffectItemData Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadArrayHeader();
            var __StatusEffectTypeId__ = default(int);
            var __ImplicitModifiers__ = default(global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Data.ModifierData>);
            var __Duration__ = default(global::Nighthollow.Stats.DurationValue?);

            for (int i = 0; i < length; i++)
            {
                switch (i)
                {
                    case 0:
                        __StatusEffectTypeId__ = reader.ReadInt32();
                        break;
                    case 1:
                        __ImplicitModifiers__ = formatterResolver.GetFormatterWithVerify<global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Data.ModifierData>>().Deserialize(ref reader, options);
                        break;
                    case 2:
                        __Duration__ = formatterResolver.GetFormatterWithVerify<global::Nighthollow.Stats.DurationValue?>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Nighthollow.Data.StatusEffectItemData(__StatusEffectTypeId__, __ImplicitModifiers__, __Duration__);
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class StatusEffectTypeDataFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Nighthollow.Data.StatusEffectTypeData>
    {

        public void Serialize(ref MessagePackWriter writer, global::Nighthollow.Data.StatusEffectTypeData value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteArrayHeader(8);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.Name, options);
            writer.Write(value.IsNamed);
            writer.Write(value.MaxStacks);
            formatterResolver.GetFormatterWithVerify<global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Data.ModifierData>>().Serialize(ref writer, value.ImplicitModifiers, options);
            formatterResolver.GetFormatterWithVerify<global::Nighthollow.Stats.DurationValue?>().Serialize(ref writer, value.Duration, options);
            formatterResolver.GetFormatterWithVerify<global::Nighthollow.Stats.DurationValue?>().Serialize(ref writer, value.DurationHigh, options);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.ImageAddress, options);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.EffectAddress, options);
        }

        public global::Nighthollow.Data.StatusEffectTypeData Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadArrayHeader();
            var __Name__ = default(string);
            var __IsNamed__ = default(bool);
            var __MaxStacks__ = default(int);
            var __ImplicitModifiers__ = default(global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Data.ModifierData>);
            var __Duration__ = default(global::Nighthollow.Stats.DurationValue?);
            var __DurationHigh__ = default(global::Nighthollow.Stats.DurationValue?);
            var __ImageAddress__ = default(string);
            var __EffectAddress__ = default(string);

            for (int i = 0; i < length; i++)
            {
                switch (i)
                {
                    case 0:
                        __Name__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __IsNamed__ = reader.ReadBoolean();
                        break;
                    case 2:
                        __MaxStacks__ = reader.ReadInt32();
                        break;
                    case 3:
                        __ImplicitModifiers__ = formatterResolver.GetFormatterWithVerify<global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Data.ModifierData>>().Deserialize(ref reader, options);
                        break;
                    case 4:
                        __Duration__ = formatterResolver.GetFormatterWithVerify<global::Nighthollow.Stats.DurationValue?>().Deserialize(ref reader, options);
                        break;
                    case 5:
                        __DurationHigh__ = formatterResolver.GetFormatterWithVerify<global::Nighthollow.Stats.DurationValue?>().Deserialize(ref reader, options);
                        break;
                    case 6:
                        __ImageAddress__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 7:
                        __EffectAddress__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Nighthollow.Data.StatusEffectTypeData(__Name__, __IsNamed__, __MaxStacks__, __ImplicitModifiers__, __Duration__, __DurationHigh__, __ImageAddress__, __EffectAddress__);
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class TableMetadataFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Nighthollow.Data.TableMetadata>
    {

        public void Serialize(ref MessagePackWriter writer, global::Nighthollow.Data.TableMetadata value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            writer.WriteArrayHeader(2);
            writer.Write(value.NextId);
            writer.Write(value.LastAccessedTime);
        }

        public global::Nighthollow.Data.TableMetadata Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            var length = reader.ReadArrayHeader();
            var __NextId__ = default(int);
            var __LastAccessedTime__ = default(long);

            for (int i = 0; i < length; i++)
            {
                switch (i)
                {
                    case 0:
                        __NextId__ = reader.ReadInt32();
                        break;
                    case 1:
                        __LastAccessedTime__ = reader.ReadInt64();
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Nighthollow.Data.TableMetadata(__NextId__, __LastAccessedTime__);
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class UserDataFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Nighthollow.Data.UserData>
    {

        public void Serialize(ref MessagePackWriter writer, global::Nighthollow.Data.UserData value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteArrayHeader(1);
            formatterResolver.GetFormatterWithVerify<global::Nighthollow.Data.School>().Serialize(ref writer, value.PrimarySchool, options);
        }

        public global::Nighthollow.Data.UserData Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadArrayHeader();
            var __PrimarySchool__ = default(global::Nighthollow.Data.School);

            for (int i = 0; i < length; i++)
            {
                switch (i)
                {
                    case 0:
                        __PrimarySchool__ = formatterResolver.GetFormatterWithVerify<global::Nighthollow.Data.School>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Nighthollow.Data.UserData(__PrimarySchool__);
            reader.Depth--;
            return ____result;
        }
    }
}

#pragma warning restore 168
#pragma warning restore 414
#pragma warning restore 618
#pragma warning restore 612

#pragma warning restore SA1129 // Do not use default value type constructor
#pragma warning restore SA1200 // Using directives should be placed correctly
#pragma warning restore SA1309 // Field names should not begin with underscore
#pragma warning restore SA1312 // Variable names should begin with lower-case letter
#pragma warning restore SA1403 // File may only contain a single namespace
#pragma warning restore SA1649 // File name should match first type name

// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY MPC(MessagePack-CSharp). DO NOT CHANGE IT.
// </auto-generated>

#pragma warning disable 618
#pragma warning disable 612
#pragma warning disable 414
#pragma warning disable 168

#pragma warning disable SA1129 // Do not use default value type constructor
#pragma warning disable SA1200 // Using directives should be placed correctly
#pragma warning disable SA1309 // Field names should not begin with underscore
#pragma warning disable SA1312 // Variable names should begin with lower-case letter
#pragma warning disable SA1403 // File may only contain a single namespace
#pragma warning disable SA1649 // File name should match first type name

namespace MessagePack.Formatters.Nighthollow.Editing.Scenarios
{
    using System;
    using System.Buffers;
    using MessagePack;

    public sealed class ScenarioDataFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Nighthollow.Editing.Scenarios.ScenarioData>
    {

        public void Serialize(ref MessagePackWriter writer, global::Nighthollow.Editing.Scenarios.ScenarioData value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteArrayHeader(5);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.Name, options);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.Description, options);
            formatterResolver.GetFormatterWithVerify<global::Nighthollow.Rules.Effects.SceneName>().Serialize(ref writer, value.Scene, options);
            formatterResolver.GetFormatterWithVerify<global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Rules.RuleEffect>>().Serialize(ref writer, value.Effects, options);
            writer.Write(value.Repeating);
        }

        public global::Nighthollow.Editing.Scenarios.ScenarioData Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadArrayHeader();
            var __Name__ = default(string);
            var __Description__ = default(string);
            var __Scene__ = default(global::Nighthollow.Rules.Effects.SceneName);
            var __Effects__ = default(global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Rules.RuleEffect>);
            var __Repeating__ = default(bool);

            for (int i = 0; i < length; i++)
            {
                switch (i)
                {
                    case 0:
                        __Name__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __Description__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 2:
                        __Scene__ = formatterResolver.GetFormatterWithVerify<global::Nighthollow.Rules.Effects.SceneName>().Deserialize(ref reader, options);
                        break;
                    case 3:
                        __Effects__ = formatterResolver.GetFormatterWithVerify<global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Rules.RuleEffect>>().Deserialize(ref reader, options);
                        break;
                    case 4:
                        __Repeating__ = reader.ReadBoolean();
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Nighthollow.Editing.Scenarios.ScenarioData(__Name__, __Description__, __Scene__, __Effects__, __Repeating__);
            reader.Depth--;
            return ____result;
        }
    }
}

#pragma warning restore 168
#pragma warning restore 414
#pragma warning restore 618
#pragma warning restore 612

#pragma warning restore SA1129 // Do not use default value type constructor
#pragma warning restore SA1200 // Using directives should be placed correctly
#pragma warning restore SA1309 // Field names should not begin with underscore
#pragma warning restore SA1312 // Variable names should begin with lower-case letter
#pragma warning restore SA1403 // File may only contain a single namespace
#pragma warning restore SA1649 // File name should match first type name

// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY MPC(MessagePack-CSharp). DO NOT CHANGE IT.
// </auto-generated>

#pragma warning disable 618
#pragma warning disable 612
#pragma warning disable 414
#pragma warning disable 168

#pragma warning disable SA1129 // Do not use default value type constructor
#pragma warning disable SA1200 // Using directives should be placed correctly
#pragma warning disable SA1309 // Field names should not begin with underscore
#pragma warning disable SA1312 // Variable names should begin with lower-case letter
#pragma warning disable SA1403 // File may only contain a single namespace
#pragma warning disable SA1649 // File name should match first type name

namespace MessagePack.Formatters.Nighthollow.Rules.Conditions
{
    using System;
    using System.Buffers;
    using MessagePack;

    public sealed class HotkeyEqualsConditionFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Nighthollow.Rules.Conditions.HotkeyEqualsCondition>
    {

        public void Serialize(ref MessagePackWriter writer, global::Nighthollow.Rules.Conditions.HotkeyEqualsCondition value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteArrayHeader(1);
            formatterResolver.GetFormatterWithVerify<global::Nighthollow.Rules.Events.HotkeyPressedEvent.KeyName>().Serialize(ref writer, value.Hotkey, options);
        }

        public global::Nighthollow.Rules.Conditions.HotkeyEqualsCondition Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadArrayHeader();
            var __Hotkey__ = default(global::Nighthollow.Rules.Events.HotkeyPressedEvent.KeyName);

            for (int i = 0; i < length; i++)
            {
                switch (i)
                {
                    case 0:
                        __Hotkey__ = formatterResolver.GetFormatterWithVerify<global::Nighthollow.Rules.Events.HotkeyPressedEvent.KeyName>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Nighthollow.Rules.Conditions.HotkeyEqualsCondition(__Hotkey__);
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class UserDeckSizeConditionFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Nighthollow.Rules.Conditions.UserDeckSizeCondition>
    {

        public void Serialize(ref MessagePackWriter writer, global::Nighthollow.Rules.Conditions.UserDeckSizeCondition value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteArrayHeader(2);
            writer.Write(value.Target);
            formatterResolver.GetFormatterWithVerify<global::Nighthollow.Rules.Conditions.IntegerOperator>().Serialize(ref writer, value.Operator, options);
        }

        public global::Nighthollow.Rules.Conditions.UserDeckSizeCondition Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadArrayHeader();
            var __Target__ = default(int);
            var __Operator__ = default(global::Nighthollow.Rules.Conditions.IntegerOperator);

            for (int i = 0; i < length; i++)
            {
                switch (i)
                {
                    case 0:
                        __Target__ = reader.ReadInt32();
                        break;
                    case 1:
                        __Operator__ = formatterResolver.GetFormatterWithVerify<global::Nighthollow.Rules.Conditions.IntegerOperator>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Nighthollow.Rules.Conditions.UserDeckSizeCondition(__Target__, __Operator__);
            reader.Depth--;
            return ____result;
        }
    }
}

#pragma warning restore 168
#pragma warning restore 414
#pragma warning restore 618
#pragma warning restore 612

#pragma warning restore SA1129 // Do not use default value type constructor
#pragma warning restore SA1200 // Using directives should be placed correctly
#pragma warning restore SA1309 // Field names should not begin with underscore
#pragma warning restore SA1312 // Variable names should begin with lower-case letter
#pragma warning restore SA1403 // File may only contain a single namespace
#pragma warning restore SA1649 // File name should match first type name

// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY MPC(MessagePack-CSharp). DO NOT CHANGE IT.
// </auto-generated>

#pragma warning disable 618
#pragma warning disable 612
#pragma warning disable 414
#pragma warning disable 168

#pragma warning disable SA1129 // Do not use default value type constructor
#pragma warning disable SA1200 // Using directives should be placed correctly
#pragma warning disable SA1309 // Field names should not begin with underscore
#pragma warning disable SA1312 // Variable names should begin with lower-case letter
#pragma warning disable SA1403 // File may only contain a single namespace
#pragma warning disable SA1649 // File name should match first type name

namespace MessagePack.Formatters.Nighthollow.Rules.Effects
{
    using System;
    using System.Buffers;
    using MessagePack;

    public sealed class CenterCameraOnHexEffectFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Nighthollow.Rules.Effects.CenterCameraOnHexEffect>
    {

        public void Serialize(ref MessagePackWriter writer, global::Nighthollow.Rules.Effects.CenterCameraOnHexEffect value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteArrayHeader(1);
            formatterResolver.GetFormatterWithVerify<global::Nighthollow.World.Data.HexPosition>().Serialize(ref writer, value.Position, options);
        }

        public global::Nighthollow.Rules.Effects.CenterCameraOnHexEffect Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadArrayHeader();
            var __Position__ = default(global::Nighthollow.World.Data.HexPosition);

            for (int i = 0; i < length; i++)
            {
                switch (i)
                {
                    case 0:
                        __Position__ = formatterResolver.GetFormatterWithVerify<global::Nighthollow.World.Data.HexPosition>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Nighthollow.Rules.Effects.CenterCameraOnHexEffect(__Position__);
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class CharacterDialogueEffectFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Nighthollow.Rules.Effects.CharacterDialogueEffect>
    {

        public void Serialize(ref MessagePackWriter writer, global::Nighthollow.Rules.Effects.CharacterDialogueEffect value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteArrayHeader(3);
            formatterResolver.GetFormatterWithVerify<global::Nighthollow.Rules.Effects.CharacterName>().Serialize(ref writer, value.CharacterName, options);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.Text, options);
            formatterResolver.GetFormatterWithVerify<int?>().Serialize(ref writer, value.OnContinueRuleId, options);
        }

        public global::Nighthollow.Rules.Effects.CharacterDialogueEffect Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadArrayHeader();
            var __CharacterName__ = default(global::Nighthollow.Rules.Effects.CharacterName);
            var __Text__ = default(string);
            var __OnContinueRuleId__ = default(int?);

            for (int i = 0; i < length; i++)
            {
                switch (i)
                {
                    case 0:
                        __CharacterName__ = formatterResolver.GetFormatterWithVerify<global::Nighthollow.Rules.Effects.CharacterName>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __Text__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 2:
                        __OnContinueRuleId__ = formatterResolver.GetFormatterWithVerify<int?>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Nighthollow.Rules.Effects.CharacterDialogueEffect(__CharacterName__, __Text__, __OnContinueRuleId__);
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class ClearScenariosEffectFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Nighthollow.Rules.Effects.ClearScenariosEffect>
    {

        public void Serialize(ref MessagePackWriter writer, global::Nighthollow.Rules.Effects.ClearScenariosEffect value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            writer.WriteArrayHeader(0);
        }

        public global::Nighthollow.Rules.Effects.ClearScenariosEffect Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            var length = reader.ReadArrayHeader();

            for (int i = 0; i < length; i++)
            {
                switch (i)
                {
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Nighthollow.Rules.Effects.ClearScenariosEffect();
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class DisplayHelpTextEffectFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Nighthollow.Rules.Effects.DisplayHelpTextEffect>
    {

        public void Serialize(ref MessagePackWriter writer, global::Nighthollow.Rules.Effects.DisplayHelpTextEffect value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteArrayHeader(4);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.Text, options);
            writer.Write(value.XPosition);
            writer.Write(value.YPosition);
            formatterResolver.GetFormatterWithVerify<global::Nighthollow.Rules.Effects.DisplayHelpTextEffect.Direction>().Serialize(ref writer, value.ArrowDirection, options);
        }

        public global::Nighthollow.Rules.Effects.DisplayHelpTextEffect Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadArrayHeader();
            var __Text__ = default(string);
            var __XPosition__ = default(int);
            var __YPosition__ = default(int);
            var __ArrowDirection__ = default(global::Nighthollow.Rules.Effects.DisplayHelpTextEffect.Direction);

            for (int i = 0; i < length; i++)
            {
                switch (i)
                {
                    case 0:
                        __Text__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __XPosition__ = reader.ReadInt32();
                        break;
                    case 2:
                        __YPosition__ = reader.ReadInt32();
                        break;
                    case 3:
                        __ArrowDirection__ = formatterResolver.GetFormatterWithVerify<global::Nighthollow.Rules.Effects.DisplayHelpTextEffect.Direction>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Nighthollow.Rules.Effects.DisplayHelpTextEffect(__Text__, __XPosition__, __YPosition__, __ArrowDirection__);
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class EnableAllRulesEffectFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Nighthollow.Rules.Effects.EnableAllRulesEffect>
    {

        public void Serialize(ref MessagePackWriter writer, global::Nighthollow.Rules.Effects.EnableAllRulesEffect value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            writer.WriteArrayHeader(0);
        }

        public global::Nighthollow.Rules.Effects.EnableAllRulesEffect Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            var length = reader.ReadArrayHeader();

            for (int i = 0; i < length; i++)
            {
                switch (i)
                {
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Nighthollow.Rules.Effects.EnableAllRulesEffect();
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class InitializeWorldMapEffectFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Nighthollow.Rules.Effects.InitializeWorldMapEffect>
    {

        public void Serialize(ref MessagePackWriter writer, global::Nighthollow.Rules.Effects.InitializeWorldMapEffect value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            writer.WriteArrayHeader(0);
        }

        public global::Nighthollow.Rules.Effects.InitializeWorldMapEffect Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            var length = reader.ReadArrayHeader();

            for (int i = 0; i < length; i++)
            {
                switch (i)
                {
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Nighthollow.Rules.Effects.InitializeWorldMapEffect();
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class LoadSceneEffectFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Nighthollow.Rules.Effects.LoadSceneEffect>
    {

        public void Serialize(ref MessagePackWriter writer, global::Nighthollow.Rules.Effects.LoadSceneEffect value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteArrayHeader(1);
            formatterResolver.GetFormatterWithVerify<global::Nighthollow.Rules.Effects.SceneName>().Serialize(ref writer, value.SceneName, options);
        }

        public global::Nighthollow.Rules.Effects.LoadSceneEffect Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadArrayHeader();
            var __SceneName__ = default(global::Nighthollow.Rules.Effects.SceneName);

            for (int i = 0; i < length; i++)
            {
                switch (i)
                {
                    case 0:
                        __SceneName__ = formatterResolver.GetFormatterWithVerify<global::Nighthollow.Rules.Effects.SceneName>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Nighthollow.Rules.Effects.LoadSceneEffect(__SceneName__);
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class PlaceCreaturesFromListEffectFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Nighthollow.Rules.Effects.PlaceCreaturesFromListEffect>
    {

        public void Serialize(ref MessagePackWriter writer, global::Nighthollow.Rules.Effects.PlaceCreaturesFromListEffect value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            writer.WriteArrayHeader(1);
            writer.Write(value.ItemList);
        }

        public global::Nighthollow.Rules.Effects.PlaceCreaturesFromListEffect Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            var length = reader.ReadArrayHeader();
            var __ItemList__ = default(int);

            for (int i = 0; i < length; i++)
            {
                switch (i)
                {
                    case 0:
                        __ItemList__ = reader.ReadInt32();
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Nighthollow.Rules.Effects.PlaceCreaturesFromListEffect(__ItemList__);
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class PreventDefaultEffectFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Nighthollow.Rules.Effects.PreventDefaultEffect>
    {

        public void Serialize(ref MessagePackWriter writer, global::Nighthollow.Rules.Effects.PreventDefaultEffect value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            writer.WriteArrayHeader(0);
        }

        public global::Nighthollow.Rules.Effects.PreventDefaultEffect Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            var length = reader.ReadArrayHeader();

            for (int i = 0; i < length; i++)
            {
                switch (i)
                {
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Nighthollow.Rules.Effects.PreventDefaultEffect();
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class ResetToNewGameStateEffectFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Nighthollow.Rules.Effects.ResetToNewGameStateEffect>
    {

        public void Serialize(ref MessagePackWriter writer, global::Nighthollow.Rules.Effects.ResetToNewGameStateEffect value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            writer.WriteArrayHeader(0);
        }

        public global::Nighthollow.Rules.Effects.ResetToNewGameStateEffect Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            var length = reader.ReadArrayHeader();

            for (int i = 0; i < length; i++)
            {
                switch (i)
                {
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Nighthollow.Rules.Effects.ResetToNewGameStateEffect();
            reader.Depth--;
            return ____result;
        }
    }
}

#pragma warning restore 168
#pragma warning restore 414
#pragma warning restore 618
#pragma warning restore 612

#pragma warning restore SA1129 // Do not use default value type constructor
#pragma warning restore SA1200 // Using directives should be placed correctly
#pragma warning restore SA1309 // Field names should not begin with underscore
#pragma warning restore SA1312 // Variable names should begin with lower-case letter
#pragma warning restore SA1403 // File may only contain a single namespace
#pragma warning restore SA1649 // File name should match first type name

// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY MPC(MessagePack-CSharp). DO NOT CHANGE IT.
// </auto-generated>

#pragma warning disable 618
#pragma warning disable 612
#pragma warning disable 414
#pragma warning disable 168

#pragma warning disable SA1129 // Do not use default value type constructor
#pragma warning disable SA1200 // Using directives should be placed correctly
#pragma warning disable SA1309 // Field names should not begin with underscore
#pragma warning disable SA1312 // Variable names should begin with lower-case letter
#pragma warning disable SA1403 // File may only contain a single namespace
#pragma warning disable SA1649 // File name should match first type name

namespace MessagePack.Formatters.Nighthollow.Rules
{
    using System;
    using System.Buffers;
    using MessagePack;

    public sealed class RuleFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Nighthollow.Rules.Rule>
    {

        public void Serialize(ref MessagePackWriter writer, global::Nighthollow.Rules.Rule value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteArrayHeader(7);
            formatterResolver.GetFormatterWithVerify<global::Nighthollow.Rules.EventName>().Serialize(ref writer, value.EventName, options);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.Name, options);
            formatterResolver.GetFormatterWithVerify<global::Nighthollow.Rules.RuleCategory>().Serialize(ref writer, value.Category, options);
            formatterResolver.GetFormatterWithVerify<global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Rules.RuleCondition>>().Serialize(ref writer, value.Conditions, options);
            formatterResolver.GetFormatterWithVerify<global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Rules.RuleEffect>>().Serialize(ref writer, value.Effects, options);
            writer.Write(value.OneTime);
            writer.Write(value.Disabled);
        }

        public global::Nighthollow.Rules.Rule Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadArrayHeader();
            var __Name__ = default(string);
            var __EventName__ = default(global::Nighthollow.Rules.EventName);
            var __Category__ = default(global::Nighthollow.Rules.RuleCategory);
            var __Conditions__ = default(global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Rules.RuleCondition>);
            var __Effects__ = default(global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Rules.RuleEffect>);
            var __OneTime__ = default(bool);
            var __Disabled__ = default(bool);

            for (int i = 0; i < length; i++)
            {
                switch (i)
                {
                    case 1:
                        __Name__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 0:
                        __EventName__ = formatterResolver.GetFormatterWithVerify<global::Nighthollow.Rules.EventName>().Deserialize(ref reader, options);
                        break;
                    case 2:
                        __Category__ = formatterResolver.GetFormatterWithVerify<global::Nighthollow.Rules.RuleCategory>().Deserialize(ref reader, options);
                        break;
                    case 3:
                        __Conditions__ = formatterResolver.GetFormatterWithVerify<global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Rules.RuleCondition>>().Deserialize(ref reader, options);
                        break;
                    case 4:
                        __Effects__ = formatterResolver.GetFormatterWithVerify<global::System.Collections.Immutable.ImmutableList<global::Nighthollow.Rules.RuleEffect>>().Deserialize(ref reader, options);
                        break;
                    case 5:
                        __OneTime__ = reader.ReadBoolean();
                        break;
                    case 6:
                        __Disabled__ = reader.ReadBoolean();
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Nighthollow.Rules.Rule(__EventName__, __Name__, __Category__, __Conditions__, __Effects__, __OneTime__, __Disabled__);
            reader.Depth--;
            return ____result;
        }
    }
}

#pragma warning restore 168
#pragma warning restore 414
#pragma warning restore 618
#pragma warning restore 612

#pragma warning restore SA1129 // Do not use default value type constructor
#pragma warning restore SA1200 // Using directives should be placed correctly
#pragma warning restore SA1309 // Field names should not begin with underscore
#pragma warning restore SA1312 // Variable names should begin with lower-case letter
#pragma warning restore SA1403 // File may only contain a single namespace
#pragma warning restore SA1649 // File name should match first type name

// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY MPC(MessagePack-CSharp). DO NOT CHANGE IT.
// </auto-generated>

#pragma warning disable 618
#pragma warning disable 612
#pragma warning disable 414
#pragma warning disable 168

#pragma warning disable SA1129 // Do not use default value type constructor
#pragma warning disable SA1200 // Using directives should be placed correctly
#pragma warning disable SA1309 // Field names should not begin with underscore
#pragma warning disable SA1312 // Variable names should begin with lower-case letter
#pragma warning disable SA1403 // File may only contain a single namespace
#pragma warning disable SA1649 // File name should match first type name

namespace MessagePack.Formatters.Nighthollow.Stats
{
    using System;
    using System.Buffers;
    using MessagePack;

    public sealed class DurationValueFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Nighthollow.Stats.DurationValue>
    {

        public void Serialize(ref MessagePackWriter writer, global::Nighthollow.Stats.DurationValue value, global::MessagePack.MessagePackSerializerOptions options)
        {
            writer.WriteArrayHeader(1);
            writer.Write(value.TimeMilliseconds);
        }

        public global::Nighthollow.Stats.DurationValue Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                throw new InvalidOperationException("typecode is null, struct not supported");
            }

            options.Security.DepthStep(ref reader);
            var length = reader.ReadArrayHeader();
            var __TimeMilliseconds__ = default(int);

            for (int i = 0; i < length; i++)
            {
                switch (i)
                {
                    case 0:
                        __TimeMilliseconds__ = reader.ReadInt32();
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Nighthollow.Stats.DurationValue(__TimeMilliseconds__);
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class IntRangeValueFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Nighthollow.Stats.IntRangeValue>
    {

        public void Serialize(ref MessagePackWriter writer, global::Nighthollow.Stats.IntRangeValue value, global::MessagePack.MessagePackSerializerOptions options)
        {
            writer.WriteArrayHeader(2);
            writer.Write(value.Low);
            writer.Write(value.High);
        }

        public global::Nighthollow.Stats.IntRangeValue Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                throw new InvalidOperationException("typecode is null, struct not supported");
            }

            options.Security.DepthStep(ref reader);
            var length = reader.ReadArrayHeader();
            var __Low__ = default(int);
            var __High__ = default(int);

            for (int i = 0; i < length; i++)
            {
                switch (i)
                {
                    case 0:
                        __Low__ = reader.ReadInt32();
                        break;
                    case 1:
                        __High__ = reader.ReadInt32();
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Nighthollow.Stats.IntRangeValue(__Low__, __High__);
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class PercentageValueFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Nighthollow.Stats.PercentageValue>
    {

        public void Serialize(ref MessagePackWriter writer, global::Nighthollow.Stats.PercentageValue value, global::MessagePack.MessagePackSerializerOptions options)
        {
            writer.WriteArrayHeader(1);
            writer.Write(value.BasisPoints);
        }

        public global::Nighthollow.Stats.PercentageValue Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                throw new InvalidOperationException("typecode is null, struct not supported");
            }

            options.Security.DepthStep(ref reader);
            var length = reader.ReadArrayHeader();
            var __BasisPoints__ = default(int);

            for (int i = 0; i < length; i++)
            {
                switch (i)
                {
                    case 0:
                        __BasisPoints__ = reader.ReadInt32();
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Nighthollow.Stats.PercentageValue(__BasisPoints__);
            reader.Depth--;
            return ____result;
        }
    }
}

#pragma warning restore 168
#pragma warning restore 414
#pragma warning restore 618
#pragma warning restore 612

#pragma warning restore SA1129 // Do not use default value type constructor
#pragma warning restore SA1200 // Using directives should be placed correctly
#pragma warning restore SA1309 // Field names should not begin with underscore
#pragma warning restore SA1312 // Variable names should begin with lower-case letter
#pragma warning restore SA1403 // File may only contain a single namespace
#pragma warning restore SA1649 // File name should match first type name

// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY MPC(MessagePack-CSharp). DO NOT CHANGE IT.
// </auto-generated>

#pragma warning disable 618
#pragma warning disable 612
#pragma warning disable 414
#pragma warning disable 168

#pragma warning disable SA1129 // Do not use default value type constructor
#pragma warning disable SA1200 // Using directives should be placed correctly
#pragma warning disable SA1309 // Field names should not begin with underscore
#pragma warning disable SA1312 // Variable names should begin with lower-case letter
#pragma warning disable SA1403 // File may only contain a single namespace
#pragma warning disable SA1649 // File name should match first type name

namespace MessagePack.Formatters.Nighthollow.World.Data
{
    using System;
    using System.Buffers;
    using MessagePack;

    public sealed class ColorDataFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Nighthollow.World.Data.ColorData>
    {

        public void Serialize(ref MessagePackWriter writer, global::Nighthollow.World.Data.ColorData value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            writer.WriteArrayHeader(3);
            writer.Write(value.RedComponent);
            writer.Write(value.GreenComponent);
            writer.Write(value.BlueComponent);
        }

        public global::Nighthollow.World.Data.ColorData Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            var length = reader.ReadArrayHeader();
            var __RedComponent__ = default(int);
            var __GreenComponent__ = default(int);
            var __BlueComponent__ = default(int);

            for (int i = 0; i < length; i++)
            {
                switch (i)
                {
                    case 0:
                        __RedComponent__ = reader.ReadInt32();
                        break;
                    case 1:
                        __GreenComponent__ = reader.ReadInt32();
                        break;
                    case 2:
                        __BlueComponent__ = reader.ReadInt32();
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Nighthollow.World.Data.ColorData(__RedComponent__, __GreenComponent__, __BlueComponent__);
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class HexDataFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Nighthollow.World.Data.HexData>
    {

        public void Serialize(ref MessagePackWriter writer, global::Nighthollow.World.Data.HexData value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteArrayHeader(3);
            formatterResolver.GetFormatterWithVerify<global::Nighthollow.World.Data.HexType>().Serialize(ref writer, value.HexType, options);
            formatterResolver.GetFormatterWithVerify<global::Nighthollow.World.Data.HexPosition>().Serialize(ref writer, value.Position, options);
            formatterResolver.GetFormatterWithVerify<int?>().Serialize(ref writer, value.OwningKingdom, options);
        }

        public global::Nighthollow.World.Data.HexData Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadArrayHeader();
            var __HexType__ = default(global::Nighthollow.World.Data.HexType);
            var __Position__ = default(global::Nighthollow.World.Data.HexPosition);
            var __OwningKingdom__ = default(int?);

            for (int i = 0; i < length; i++)
            {
                switch (i)
                {
                    case 0:
                        __HexType__ = formatterResolver.GetFormatterWithVerify<global::Nighthollow.World.Data.HexType>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __Position__ = formatterResolver.GetFormatterWithVerify<global::Nighthollow.World.Data.HexPosition>().Deserialize(ref reader, options);
                        break;
                    case 2:
                        __OwningKingdom__ = formatterResolver.GetFormatterWithVerify<int?>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Nighthollow.World.Data.HexData(__HexType__, __Position__, __OwningKingdom__);
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class HexPositionFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Nighthollow.World.Data.HexPosition>
    {

        public void Serialize(ref MessagePackWriter writer, global::Nighthollow.World.Data.HexPosition value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            writer.WriteArrayHeader(2);
            writer.Write(value.X);
            writer.Write(value.Y);
        }

        public global::Nighthollow.World.Data.HexPosition Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            var length = reader.ReadArrayHeader();
            var __X__ = default(int);
            var __Y__ = default(int);

            for (int i = 0; i < length; i++)
            {
                switch (i)
                {
                    case 0:
                        __X__ = reader.ReadInt32();
                        break;
                    case 1:
                        __Y__ = reader.ReadInt32();
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Nighthollow.World.Data.HexPosition(__X__, __Y__);
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class KingdomDataFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Nighthollow.World.Data.KingdomData>
    {

        public void Serialize(ref MessagePackWriter writer, global::Nighthollow.World.Data.KingdomData value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteArrayHeader(4);
            formatterResolver.GetFormatterWithVerify<global::Nighthollow.World.Data.KingdomName>().Serialize(ref writer, value.Name, options);
            formatterResolver.GetFormatterWithVerify<global::Nighthollow.World.Data.HexPosition>().Serialize(ref writer, value.StartingPosition, options);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.TileImageAddress, options);
            formatterResolver.GetFormatterWithVerify<global::Nighthollow.World.Data.ColorData>().Serialize(ref writer, value.Color, options);
        }

        public global::Nighthollow.World.Data.KingdomData Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadArrayHeader();
            var __Name__ = default(global::Nighthollow.World.Data.KingdomName);
            var __StartingPosition__ = default(global::Nighthollow.World.Data.HexPosition);
            var __TileImageAddress__ = default(string);
            var __Color__ = default(global::Nighthollow.World.Data.ColorData);

            for (int i = 0; i < length; i++)
            {
                switch (i)
                {
                    case 0:
                        __Name__ = formatterResolver.GetFormatterWithVerify<global::Nighthollow.World.Data.KingdomName>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __StartingPosition__ = formatterResolver.GetFormatterWithVerify<global::Nighthollow.World.Data.HexPosition>().Deserialize(ref reader, options);
                        break;
                    case 2:
                        __TileImageAddress__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 3:
                        __Color__ = formatterResolver.GetFormatterWithVerify<global::Nighthollow.World.Data.ColorData>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Nighthollow.World.Data.KingdomData(__Name__, __StartingPosition__, __TileImageAddress__, __Color__);
            reader.Depth--;
            return ____result;
        }
    }
}

#pragma warning restore 168
#pragma warning restore 414
#pragma warning restore 618
#pragma warning restore 612

#pragma warning restore SA1129 // Do not use default value type constructor
#pragma warning restore SA1200 // Using directives should be placed correctly
#pragma warning restore SA1309 // Field names should not begin with underscore
#pragma warning restore SA1312 // Variable names should begin with lower-case letter
#pragma warning restore SA1403 // File may only contain a single namespace
#pragma warning restore SA1649 // File name should match first type name

